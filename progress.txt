## Codebase Patterns
- This is a Turborepo monorepo with pnpm as package manager
- Quality checks available: `pnpm run lint` and `pnpm run check-types`
- Pre-existing type errors may exist in the codebase - isolate your changes and commit only what's relevant to your story
- React Native mobile app located in /apps/mobile
- Key files for this PRD:
  - Timeline building: /apps/mobile/src/lib/calendar/actual-display-events.ts
  - Event editing: /apps/mobile/src/components/molecules/EventEditorModal.tsx
  - Actual adjust screen: /apps/mobile/src/app/actual-adjust.tsx
  - Location services: /apps/mobile/src/lib/supabase/services/location-samples.ts
  - Events store: /apps/mobile/src/stores/events-store.ts
  - Error logger: /apps/mobile/src/lib/android-location/error-logger.ts
- AsyncStorage key convention: `tm:location:<purpose>` (e.g., `tm:location:errors`, `tm:location:pending:<userId>`)
- android-location module uses barrel exports from index.ts - always re-export new modules there
- Error logging uses `logError(ErrorCategory, message, context)` - import from `@/lib/android-location`
- SafeAreaView must be imported from 'react-native-safe-area-context' not 'react-native' for proper notch/status bar handling
- Templates can either use SafeAreaView directly, useSafeAreaInsets hook with manual padding, or delegate to SetupStepLayout
- Android DateTimePicker: Use `display="default"` (native modal) not `display="spinner"` (inline) for proper state persistence
- For slide-up modals on Android, add `paddingTop: insets.top` to prevent header content from being blocked by status bar
- When parsing database timestamps, use `parseDbTimestamp()` helper (in calendar-events.ts) to ensure UTC interpretation
- Task heartbeat tracking: `recordTaskHeartbeat(sampleCount)` persists last execution time to AsyncStorage key `tm:location:lastTaskExecution`; use `getLastTaskHeartbeat()` to read it
- Movement state: `getMovementState()` / `setMovementState(state, reason)` persist to AsyncStorage key `tm:location:movementState`; returns `MovementStateData` with state, lastUpdated, reason; defaults to 'unknown' on missing/corrupt data
- Movement detection: `classifyMovementByDistance(samples)` takes `LocationSampleInput[]`, filters by accuracy <=50m, ignores GPS drift <10m, classifies as moving (>200m/15min) or stationary (<50m/30min) with confidence 0.7-1.0; returns null state for ambiguous/insufficient data
- Adaptive sync: Android uses movement-aware sync intervals (30 min stationary, 15 min moving/unknown) plus queue-size threshold checks (10 stationary, 20 moving/unknown); iOS uses fixed 2-min interval
- Sync timing: `recordLastSyncTime()` / `getLastSyncTime()` persist to AsyncStorage key `tm:location:lastSyncTime`

---

## 2026-01-22 - US-001
- What was implemented: Fixed SafeAreaView imports in 3 template files
- Files changed:
  - apps/mobile/src/components/templates/PersonalizationTemplate.tsx
  - apps/mobile/src/components/templates/AppCategoryOverridesTemplate.tsx
  - apps/mobile/src/components/templates/PatternInsightsTemplate.tsx
- **Learnings for future iterations:**
  - 3 templates were using SafeAreaView from 'react-native' (wrong) instead of 'react-native-safe-area-context' (correct)
  - Other templates either: 1) correctly import from react-native-safe-area-context, 2) use useSafeAreaInsets hook with manual padding, or 3) delegate to SetupStepLayout which handles safe areas
  - SetupStepLayout at /apps/mobile/src/components/organisms/SetupStepLayout.tsx properly wraps with SafeAreaView from react-native-safe-area-context
---

## 2026-01-22 - US-002
- What was implemented: Audited and fixed SafeAreaView usage in screen files
- Files changed:
  - apps/mobile/src/app/dev/ios-insights.tsx
  - apps/mobile/src/app/dev/android-insights.tsx
- **Learnings for future iterations:**
  - Most screen files delegate to templates that handle safe areas - no direct SafeAreaView needed in screens
  - Dev screens using Stack.Screen with headerShown: true still need SafeAreaView for bottom edge (edges={['bottom']}) since header handles top
  - All 44 templates already have proper SafeAreaView handling (from react-native-safe-area-context)
  - No floating/debug "orange icon" was found in the codebase - this may have been a runtime visual artifact
  - Pre-existing type errors exist in the codebase (CalendarEventMeta, Json types) - these are unrelated to SafeAreaView changes
---

## 2026-01-22 - US-003
- What was implemented: Fixed Android date/time picker state persistence in AddEventTemplate
- Files changed:
  - apps/mobile/src/components/templates/AddEventTemplate.tsx
- **Learnings for future iterations:**
  - On Android, `display="spinner"` for DateTimePicker renders inline but has state persistence issues
  - On Android, use `display="default"` which shows native modal dialog and properly persists state
  - iOS can continue using `display="spinner"` for inline picker experience
  - Pattern: Platform-specific rendering with `Platform.OS === 'ios'` / `Platform.OS === 'android'` conditionals
  - The existing Android dismiss handling (`setShowPicker(false)` on any event type) was already correct
  - The 9:30am default is intentional when `initialStartMinutes` is undefined, not a bug
---

## 2026-01-22 - US-004
- What was implemented: Fixed Android date/time picker in EventEditorModal
- Files changed:
  - apps/mobile/src/components/molecules/EventEditorModal.tsx
- **Learnings for future iterations:**
  - For modals that slide up 92% of screen height, add `paddingTop: Platform.OS === 'android' ? insets.top : 0` to prevent header buttons from being blocked by status bar
  - EventEditorModal now uses same Android date/time picker pattern as AddEventTemplate: `display="default"` (native modal) for Android, `display="spinner"` (inline) for iOS
  - Must close picker state (`setShowPicker(false)`) on ANY Android event including 'dismissed' to prevent modal re-open loop
  - The `useSafeAreaInsets` hook is already imported from 'react-native-safe-area-context' - use `insets.top` for top padding, `insets.bottom` for bottom padding
---

## 2026-01-22 - US-005
- What was implemented: Added defensive UTC parsing for database timestamps to ensure correct timezone handling
- Files changed:
  - apps/mobile/src/lib/supabase/services/calendar-events.ts
  - apps/mobile/src/lib/calendar/actual-display-events.ts
  - apps/mobile/src/lib/supabase/services/actual-evidence-events.ts
- **Learnings for future iterations:**
  - Database timestamps (from Supabase) should always include timezone info (Z suffix or offset), but defensive parsing is safer
  - `parseDbTimestamp()` helper ensures timestamps without timezone info are interpreted as UTC, not local time
  - JavaScript's `new Date("2026-01-22T15:00:00")` (no Z) interprets as LOCAL time, while `new Date("2026-01-22T15:00:00Z")` interprets as UTC
  - This difference can cause events to appear hours off depending on user timezone
  - The same pattern should be used anywhere database timestamps are parsed: `parseDbTimestamp(row.timestamp)` instead of `new Date(row.timestamp)`
  - Pre-existing type errors (CalendarEventMeta export, Json types) are unrelated to timezone handling
---

## 2026-01-27 - US-002
- What was implemented: Created ErrorLogger infrastructure with AsyncStorage persistence for location tracking diagnostics
- Files changed:
  - apps/mobile/src/lib/android-location/error-logger.ts (new)
  - apps/mobile/src/lib/android-location/index.ts (added exports)
- **Learnings for future iterations:**
  - AsyncStorage key for errors: `tm:location:errors`
  - Circular buffer pattern: read all, append/throttle, write back trimmed to max 50
  - Duplicate throttling: scan from end of array for matching category+message within 5-min window, increment count instead of appending
  - ErrorCategory enum: PERMISSION_DENIED, TASK_START_FAILED, TASK_EXECUTION_FAILED, LOCATION_UNAVAILABLE, SYNC_FAILED
  - All public functions (logError, getRecentErrors, clearErrors) wrap in try/catch and fail silently - logging must never crash the app
  - Export both values and types from barrel index.ts: `export { ErrorCategory }` for the enum, `export type { ErrorLogEntry }` for the interface
  - US-003 will integrate logError() calls into existing location code paths (location-task.ts, index.ts, permissions.ts, queue.ts)
---

## 2026-01-27 - US-003
- What was implemented: Integrated error logging (logError) calls into all location tracking error paths across 3 files
- Files changed:
  - apps/mobile/src/lib/android-location/location-task.ts (added logError to 5 error paths: task error callback, empty locations, no user session, all samples invalid, catch block)
  - apps/mobile/src/lib/android-location/index.ts (added logError to 7 error paths: bg permission check failure, bg permission request failure, start tracking - no module/no services/fg denied/bg denied/start exception, flush sync failure)
  - apps/mobile/src/lib/supabase/hooks/use-location-samples-sync.ts (added logError to 2 error paths: start tracking failure, flush failure)
- **Learnings for future iterations:**
  - There is no separate `permissions.ts` file - all permission logic lives in `index.ts` within `requestAndroidLocationPermissionsAsync()` and `getBackgroundPermissionsSafeAsync()`
  - `queue.ts` has no direct error paths needing logging - it's called by location-task.ts (enqueue) and index.ts (flush), which now log errors at the caller level
  - `logError()` is async but returns void - in fire-and-forget contexts (like the background task), no need to await it
  - Context objects should include `androidApiLevel: getAndroidApiLevel()` for diagnostic value on every error
  - When wrapping an existing function body in try/catch for logging (like `startAndroidBackgroundLocationAsync` and `flushPending`), re-throw the error after logging so callers still see the failure
  - `use-location-samples-sync.ts` imports from `@/lib/android-location` barrel - added `ErrorCategory` and `logError` to its import
  - Pre-existing type errors exist in index.ts (`status: 'denied'` literal vs PermissionStatus type) - unrelated to this change
---

## 2026-01-27 - US-004
- What was implemented: Updated location task configuration for 15-minute intervals with heartbeat tracking
- Files changed:
  - apps/mobile/src/lib/android-location/index.ts (updated startLocationUpdatesAsync options: timeInterval 2min→15min, added deferredUpdatesInterval: 900000, added showsBackgroundLocationIndicator: true; added barrel exports for task-heartbeat)
  - apps/mobile/src/lib/android-location/location-task.ts (added recordTaskHeartbeat() calls: initial heartbeat with 0 on every callback, updated heartbeat with actual sampleCount on success)
  - apps/mobile/src/lib/android-location/task-heartbeat.ts (new: recordTaskHeartbeat(sampleCount) and getLastTaskHeartbeat() with AsyncStorage key tm:location:lastTaskExecution)
- **Learnings for future iterations:**
  - expo-location's `startLocationUpdatesAsync` accepts `LocationTaskOptions` which extends `LocationOptions` with `deferredUpdatesInterval`, `deferredUpdatesDistance`, `showsBackgroundLocationIndicator` (iOS), `activityType` (iOS), `pausesUpdatesAutomatically` (iOS)
  - `timeInterval` is Android-only, controls minimum time between location updates
  - `deferredUpdatesInterval` batches deferred updates - set to match timeInterval for consistent cadence
  - `showsBackgroundLocationIndicator` is iOS-only but harmless to include on Android (ignored)
  - Heartbeat pattern: record at start of callback (sampleCount=0), update after success (sampleCount=actual) - this way even error/early-return executions are tracked
  - `recordTaskHeartbeat()` is fire-and-forget (async but not awaited in the task) - same pattern as `logError()`
  - Future stories (US-010 health check) can use `getLastTaskHeartbeat()` to check if the task is still firing within expected intervals
---

## 2026-01-27 - US-005
- What was implemented: Haversine distance calculation utility with comprehensive unit tests
- Files changed:
  - apps/mobile/src/lib/android-location/distance.ts (new: Coordinate interface, calculateDistance() using haversine formula, returns meters)
  - apps/mobile/src/lib/android-location/distance.test.ts (new: 9 unit tests covering identical points, long distances, short distances, equator, antimeridian, symmetry, GPS drift, poles)
  - apps/mobile/src/lib/android-location/index.ts (added barrel exports for calculateDistance and Coordinate type)
- **Learnings for future iterations:**
  - Jest test framework is configured in apps/mobile with `jest-expo` preset and `jest.config.cjs`
  - Test files go alongside source files as `*.test.ts` (co-located pattern)
  - Tests run with `npx jest <path>` from apps/mobile directory or `pnpm test` for all
  - Haversine formula uses Earth radius of 6,371,000 meters for great-circle distance
  - The Coordinate interface is simple `{ latitude, longitude }` in degrees - future stories (US-007 movement detection) will use this with AndroidLocationSample coordinates
  - Export pattern for new modules: `export { fn } from './module'` and `export type { Type } from './module'` in barrel index.ts
---

## 2026-01-27 - US-006
- What was implemented: Movement state persistence module with AsyncStorage for tracking moving/stationary/unknown states
- Files changed:
  - apps/mobile/src/lib/android-location/movement-state.ts (new: MovementState, MovementReason, MovementStateData types; getMovementState() and setMovementState() with AsyncStorage persistence)
  - apps/mobile/src/lib/android-location/index.ts (added barrel exports for getMovementState, setMovementState, MovementState, MovementReason, MovementStateData)
- **Learnings for future iterations:**
  - AsyncStorage key for movement state: `tm:location:movementState`
  - MovementState is a union type `'moving' | 'stationary' | 'unknown'`, not an enum (simpler for JSON serialization)
  - MovementReason is `'activity' | 'distance'` - tracks what triggered the state change (activity recognition vs distance calculation)
  - Always include a runtime type guard (`isMovementStateData()`) when deserializing JSON from AsyncStorage - gracefully falls back to default 'unknown' state
  - Default state pattern: return `{ state: 'unknown', lastUpdated: now, reason: 'distance' }` when nothing stored or data is corrupt
  - US-007 (movement detection) and US-008 (task integration) will call `setMovementState()` to persist classification results
  - US-009 (adaptive sync) and US-010 (health check) will read movement state via `getMovementState()` to adjust intervals
---

## 2026-01-27 - US-007
- What was implemented: Distance-based movement detection with comprehensive unit tests
- Files changed:
  - apps/mobile/src/lib/android-location/movement-detector.ts (new: classifyMovementByDistance(), LocationSampleInput, MovementClassification types)
  - apps/mobile/src/lib/android-location/movement-detector.test.ts (new: 17 unit tests)
  - apps/mobile/src/lib/android-location/index.ts (added barrel exports for classifyMovementByDistance, LocationSampleInput, MovementClassification)
- **Learnings for future iterations:**
  - `classifyMovementByDistance()` accepts `LocationSampleInput[]` with latitude, longitude, accuracy_m, recorded_at fields
  - Accuracy filter: samples with `accuracy_m > 50` or `null` are excluded before classification
  - GPS drift: consecutive-pair distances < 10m are zeroed to prevent false movement from GPS jitter
  - Moving threshold: total distance > 200m AND time span >= 15 minutes
  - Stationary threshold: total distance < 50m AND time span >= 30 minutes
  - Ambiguous zone: 50-200m distance, or insufficient time span → returns `state: null`
  - Confidence: ranges 0.7-1.0, calculated from distance ratio (moving) or time+stillness ratio (stationary)
  - Minimum 3 usable samples required for any classification
  - Samples are sorted internally by timestamp, so caller order doesn't matter
  - US-008 will integrate this into location-task.ts to call on every batch of location samples
---

## 2026-01-27 - US-008
- What was implemented: Integrated movement detection into the location background task, with in-memory sample buffer and automatic state persistence
- Files changed:
  - apps/mobile/src/lib/android-location/location-task.ts (added movement detection integration: imports for classifyMovementByDistance/getMovementState/setMovementState, in-memory recentSamplesBuffer with MAX_RECENT_SAMPLES=10, updateMovementDetection() function, sample buffer population after successful enqueue, movement classification and state update on every callback)
- **Learnings for future iterations:**
  - Module-level arrays in location-task.ts persist across task callbacks but clear on process/task restart - perfect for in-memory sample buffers
  - The `classifyMovementByDistance()` requires at least 3 usable samples (accuracy <=50m) for any classification, so the buffer needs to accumulate over multiple callbacks
  - Movement state changes are persisted via `setMovementState()` to AsyncStorage (key: tm:location:movementState) - this doubles as diagnostic logging since it includes lastUpdated timestamp
  - The `updateMovementDetection()` function is wrapped in try/catch and fails silently - movement detection must never crash the background location task
  - Confidence threshold of 0.7 (70%) matches the minimum confidence returned by `classifyMovementByDistance()` for definitive classifications
  - State is only updated when it differs from current persisted state - avoids unnecessary AsyncStorage writes
  - US-009 (adaptive sync) will read movement state via `getMovementState()` to adjust sync intervals
  - US-010 (health check) will use movement state for expected interval calculations
---

## 2026-01-27 - US-009
- What was implemented: Adaptive sync intervals based on movement state for Android location data upload
- Files changed:
  - apps/mobile/src/lib/android-location/sync-timing.ts (new: recordLastSyncTime() and getLastSyncTime() with AsyncStorage key tm:location:lastSyncTime)
  - apps/mobile/src/lib/android-location/index.ts (added barrel exports for peekPendingAndroidLocationSamplesAsync, recordLastSyncTime, getLastSyncTime)
  - apps/mobile/src/lib/supabase/hooks/use-location-samples-sync.ts (split into separate iOS and Android sync effects; Android uses adaptive time-based + queue-based sync)
- **Learnings for future iterations:**
  - The sync hook previously used a single useEffect for both iOS and Android with Platform.OS checks - splitting into separate effects makes each platform's logic clearer and independently testable
  - Android adaptive sync uses two complementary mechanisms: (1) time-based via setTimeout chain that re-reads movement state on each cycle, (2) queue-size polling via setInterval every 60s
  - setTimeout chain (instead of setInterval) allows dynamic interval adjustment - each cycle reads current movement state and computes the next delay accordingly
  - `peekPendingAndroidLocationSamplesAsync(userId, threshold + 1)` is used to check queue size without reading all samples - peek with threshold+1 is sufficient to know if threshold is met
  - `recordLastSyncTime()` is fire-and-forget (no await needed) - same pattern as other AsyncStorage writes in the location system
  - The `isFlushingRef` is shared between iOS and Android effects since only one platform runs at a time - this prevents concurrent flushes from time-based and queue-based triggers
  - US-010 (health check) and US-012 (diagnostics) can use `getLastSyncTime()` to check sync recency
---

