# Ralph Progress Log
# Feature: Location-Informed Actual Ingestion with Sessionization
# Branch: ralph/location-informed-actual-ingestion
# Started: 2026-01-29

## Codebase Patterns
- Migration naming: `YYYYMMDD_description_of_migration.sql` in `supabase/migrations/`
- All tm schema tables use `user_id uuid NOT NULL references auth.users(id) on delete cascade`
- Idempotent SQL: Use `create table if not exists`, `create index if not exists`
- RLS policy creation uses DO blocks with pg_policies checks for idempotency
- Triggers for updated_at use `public.update_updated_at_column()` function
- Grants: `grant usage on schema tm to authenticated; grant select, insert, update, delete on tm.table to authenticated;`
- TypeScript pre-existing errors in codebase - not blocking for SQL migrations
- Services pattern: Use `tmSchema()` helper function for `supabase.schema("tm")` access
- Error handling: Use `handleSupabaseError()` wrapper and graceful fallbacks for missing tables
- Location segments: Use haversineDistance for coordinate matching, LocationSegment interface for event creation
- Commute detection: Movement = 2+ unique places OR >200m total distance; 10min threshold for separate segment
- Reconciliation priority: protected (4) > screen_time (3) > location (2) > unknown (1); use computeReconciliationOpsWithPriority for final reconciliation
- Sleep detection: isHomePlace checks HOME_PLACE_LABELS array, isWithinSleepSchedule uses UTC hours for consistency
- Sleep sessions have meta.intent='sleep' and title format '[Place] - Sleep'
- Screen-time during sleep gets meta.during_scheduled_sleep=true
- Ingestion hook: useActualIngestion in hooks/use-actual-ingestion.ts, processWindow for single 30-min window
- Window alignment: 30-min boundaries (00:00, 00:30, 01:00, etc.) using setMinutes(windowStartMinutes, 0, 0)
- Session block display: meta.kind='session_block', intent-based colors in CATEGORY_STYLES with intent_* prefix
- Session block subtitle: meta.summary array format `{ label: string; seconds: number }` for top apps
- Session detail modal: SessionDetailModal in components/molecules, opens for session_block events in actual column
- Modal pattern: Use Animated.Value for backdrop opacity and panel translateY, spring animation on show
- Session split: splitSession in actual-ingestion.ts for core logic, splitSessionEvent in calendar-events.ts for DB ops
- Soft delete pattern: Set meta.deleted_at and meta.deleted_reason on original event rather than hard delete
- User-created events: Set meta.source='user' to protect from future ingestion overwrite
- Split lineage: Set meta.split_from to original event ID on both new events
- Session merge: mergeSessions in actual-ingestion.ts for core logic, mergeSessionEvents in calendar-events.ts for DB ops
- Merge lineage: Set meta.merged_from to array of original event IDs on merged event
- Mergeable neighbors: Adjacent sessions within 5 min gap, found with findMergeableNeighbors helper
- Add Place: createUserPlace in user-places.ts creates place from lat/lon coordinates
- Place labels: PLACE_LABEL_SUGGESTIONS constant provides common suggestions (Home, Office, Gym, etc.)
- Unknown location detection: meta.place_id is null AND (no label OR "Unknown" OR "Near X") AND has lat/lon coords
- Coordinate storage: meta.latitude/longitude on session blocks for "Add Place" functionality

- Places settings: Profile > Place Labels navigates to /settings/place-labels
- Radius editing: HardenedSlider for 50-500m range with step of 10m
- PlaceLabelItem interface includes radius_m for display and editing
- Google Places API: fetchNearbyPlaces with 15-min cache, getPlaceTypeLabel for display, mapPlaceTypeToCategory for user places
- Google Places config: googlePlacesApiKey in app.config.js extra, env var EXPO_PUBLIC_GOOGLE_PLACES_API_KEY
- Place suggestion: PlaceSuggestionPrompt component shows "Are you at X?" with Accept/Reject/alternatives
- App category settings: Profile > App Categories navigates to /settings/app-categories
- App category types: AppCategory (work/social/entertainment/comms/utility/ignore) for intent, distinct from EventCategory
- Recently used apps: fetchRecentlyUsedApps queries screen_time_app_daily for 30-day aggregated usage
- App category override: upsertAppCategoryOverride saves to tm.user_app_categories with AppCategory type

---

## 2026-01-29 - US-026
- **What was implemented:** App category overrides settings for intent classification
- **Files changed:**
  - `apps/mobile/src/components/templates/AppCategorySettingsTemplate.tsx` (new)
  - `apps/mobile/src/app/settings/app-categories.tsx` (new)
  - `apps/mobile/src/lib/supabase/services/user-app-categories.ts` (modified)
  - `apps/mobile/src/components/templates/index.ts` (modified)
  - `apps/mobile/src/app/profile.tsx` (modified)
- **AppCategorySettingsTemplate features:**
  - Search bar to filter apps by name
  - List of apps with display name, 30-day usage time, current category badge
  - "Custom" indicator for user-overridden categories
  - Category selection modal with 6 options: Work, Social, Entertainment, Communication, Utility, Ignore
  - Color-coded category badges matching intent classification colors
- **Service layer additions (user-app-categories.ts):**
  - `RecentlyUsedApp` interface with appKey, displayName, totalSeconds, category, isOverride
  - `fetchRecentlyUsedApps(userId)` - Queries screen_time_app_daily for 30-day aggregated app usage
  - `upsertAppCategoryOverride({ userId, appKey, appName, category })` - Saves override with AppCategory type
  - `fetchUserAppCategoryOverridesForIntent(userId)` - Fetches overrides as IntentAppCategoryOverrides for classification
  - Imports AppCategory and getAppCategory from app-categories.ts for category lookup
- **Profile.tsx changes:**
  - Added Smartphone icon import from lucide-react-native
  - Added "App Categories" item to personalizationItems array with router.push("/settings/app-categories")
- **Learnings for future iterations:**
  - AppCategory (work/social/entertainment/comms/utility/ignore) is for intent classification
  - EventCategory (routine/work/meal/meeting/health/...) is for calendar events
  - screen_time_app_daily table contains app usage aggregated by day with app_id, display_name, duration_seconds
  - getAppCategory already checks user overrides before defaults (line 333-338 in app-categories.ts)

---

## 2026-01-29 - US-025
- **What was implemented:** Google Places auto-suggest for unknown locations
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/google-places.ts` (new)
  - `apps/mobile/src/components/molecules/PlaceSuggestionPrompt.tsx` (new)
  - `apps/mobile/src/components/molecules/SessionDetailModal.tsx` (modified)
  - `apps/mobile/app.config.js` (modified)
- **google-places.ts service:**
  - `fetchNearbyPlaces(lat, lon, radiusM?)` - Main API function with 15-min TTL in-memory cache
  - `GooglePlaceSuggestion` interface with placeId, name, vicinity, types, distanceM, coordinates, rating, isOpen
  - `getCacheKey(lat, lon)` - Rounds to 4 decimal places (~11m precision) for cache grouping
  - `clearExpiredCache()` / `clearAllCache()` / `getCacheStats()` - Cache management
  - `getPlaceTypeLabel(types)` - Maps Google types to friendly display names
  - `mapPlaceTypeToCategory(types)` - Maps types to user place categories (home/work/gym/cafe/restaurant/other)
  - `getBestSuggestion(suggestions)` - Returns top suggestion by priority and distance
  - `isGooglePlacesAvailable()` - Checks if API key is configured
  - Constants: CACHE_TTL_MS (15 min), SEARCH_RADIUS_M (100m), MAX_SUGGESTIONS (5), PRIORITY_TYPES list
- **PlaceSuggestionPrompt component:**
  - Shows "Are you at [Place]?" prompt with type label, distance, rating, vicinity
  - Accept/Reject buttons with loading state
  - "See N other suggestions" expandable list of alternatives
  - "Use Near [Area]" fallback option
  - Gracefully handles no suggestions or API unavailable
- **SessionDetailModal changes:**
  - Added suggestionDismissed state to track if user rejected suggestion
  - showGooglePlacesSuggestion computed: canAddPlace AND !suggestionDismissed AND isGooglePlacesAvailable()
  - handleAcceptPlaceSuggestion - Creates user place with suggestion's name and coordinates
  - handleRejectPlaceSuggestion - Dismisses suggestion and opens AddPlaceModal for manual entry
  - handleUseFallbackPlace - Creates place with "Near [Area]" label
  - PlaceSuggestionPrompt shown between Time Range and Actions sections
  - "Add Place" button only shown when suggestion not showing
- **app.config.js changes:**
  - Added googlePlacesApiKey to development/staging/production ENV configs
  - Falls back to EXPO_PUBLIC_GOOGLE_PLACES_API_KEY if environment-specific not set
- **Learnings for future iterations:**
  - Google Places API requires Places API (not Maps JS) enabled in GCP console
  - Cache TTL 15 min balances freshness with API cost savings
  - 100m search radius works well for precise location matching
  - Suggestion rejection should open manual entry modal (AddPlaceModal)
  - Coordinates from suggestion can be more accurate than session coordinates for place center

---

## 2026-01-29 - US-024
- **What was implemented:** Places management in settings with radius editing
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/user-places.ts` (modified)
  - `apps/mobile/src/components/templates/PlaceLabelsTemplate.tsx` (modified)
  - `apps/mobile/src/app/settings/place-labels.tsx` (modified)
- **Service layer (user-places.ts):**
  - Updated `updateUserPlace` to accept `radius_m` in updates parameter
  - Allows changing label, category, category_id, and radius_m
- **Template layer (PlaceLabelsTemplate.tsx):**
  - Added `editRadiusM` state for tracking radius during editing
  - Added radius slider using HardenedSlider (50-500m, step 10)
  - Display mode shows radius with Ruler icon (e.g., "150m")
  - Edit mode includes labeled slider with size indicator (Small/Medium/Large)
  - Helper text explains detection radius purpose
  - Updated `onUpdatePlace` prop signature to include radiusM parameter
- **Screen layer (place-labels.tsx):**
  - Updated `handleUpdatePlace` to pass radius_m to updateUserPlace
  - Local state update includes radius_m for immediate UI feedback
- **Learnings for future iterations:**
  - Use HardenedSlider from @/components/atoms instead of @react-native-community/slider (not installed)
  - HardenedSlider uses min/max/step/onChange props (different API from community slider)
  - Radius display uses Ruler icon from lucide-react-native

---

## 2026-01-29 - US-023
- **What was implemented:** Add place functionality for labeling unknown locations
- **Files changed:**
  - `apps/mobile/src/components/molecules/AddPlaceModal.tsx` (new)
  - `apps/mobile/src/components/molecules/SessionDetailModal.tsx` (modified)
  - `apps/mobile/src/lib/supabase/services/user-places.ts` (modified)
  - `apps/mobile/src/lib/supabase/services/actual-ingestion.ts` (modified)
  - `apps/mobile/src/stores/events-store.ts` (modified)
- **AddPlaceModal component:**
  - Modal with place label suggestions (Home, Office, Gym, Coffee Shop, Restaurant, Library, Park)
  - Suggestion chips with visual selection state
  - Custom text input for other place names
  - Info text explaining 150m auto-tagging radius
  - onSave callback with label and auto-detected category
- **user-places.ts additions:**
  - `createUserPlace(input)` - Creates place from lat/lon coordinates with GeoJSON center
  - `PLACE_LABEL_SUGGESTIONS` - Array of common place labels
  - `getSuggestedCategory(label)` - Returns home/work/gym/cafe/restaurant/other based on label
  - `PlaceCategory` type for category values
  - Exported `UserPlaceRow` interface for type safety
- **SessionDetailModal changes:**
  - Added canAddPlace logic: no place_id AND unknown/near label AND has lat/lon coordinates
  - Added handleAddPlacePress to show AddPlaceModal
  - Added handleSavePlace to call createUserPlace and show success alert
  - "Add Place" button in ACTIONS section with Plus icon and green styling
  - AddPlaceModal rendered at end of component
- **actual-ingestion.ts changes:**
  - SessionBlock.meta now includes optional latitude/longitude fields
  - createSessionBlock extracts lat/lon from location events (first with location OR first with coords)
  - Coordinates propagate through to stored events for "Add Place" action
- **events-store.ts changes:**
  - CalendarEventMeta interface extended with latitude/longitude optional fields
- **Learnings for future iterations:**
  - tm.user_places.center stores GeoJSON Point format: { type: "Point", coordinates: [lon, lat] }
  - Unknown location = no place_id AND (no label OR "Unknown" OR starts with "Near ")
  - Default place radius is 150m, matching location segment radius
  - Coordinates flow: LocationSegment -> DerivedEvent.meta -> SessionBlock.meta -> CalendarEventMeta

---

## 2026-01-29 - US-022
- **What was implemented:** Session merge functionality allowing users to combine adjacent sessions into one block
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/actual-ingestion.ts` (added mergeSessions, mergeScheduledEventSessions, SessionMergeResult interface)
  - `apps/mobile/src/lib/supabase/services/calendar-events.ts` (added mergeSessionEvents, MergeSessionInput/Result interfaces, findMergeableNeighbors)
  - `apps/mobile/src/components/molecules/SessionDetailModal.tsx` (added merge UI with neighbor selection)
  - `apps/mobile/src/components/templates/ComprehensiveCalendarTemplate.tsx` (added allActualEvents and onMerge props)
- **Service layer (actual-ingestion.ts):**
  - `mergeSessions(sessions, userOverrides)` - Core merge logic for 2+ sessions
  - Combines child event IDs from all source sessions
  - Combines app summaries and recalculates intent via classifyIntent
  - Calculates weighted average confidence based on duration
  - Returns SessionMergeResult with mergedSession and originalSessionIds
  - `mergeScheduledEventSessions` - Convenience wrapper for ScheduledEvent format
- **Database layer (calendar-events.ts):**
  - `mergeSessionEvents(input)` - Persists merge to database
  - Soft-deletes all originals by setting meta.deleted_at and meta.deleted_reason='merged'
  - Creates new event with meta.source='user' (protected from ingestion)
  - Links new event via meta.merged_from to array of original event IDs
  - `findMergeableNeighbors(event, allEvents)` - Finds adjacent session blocks
  - Adjacent = ends where session starts OR starts where session ends (within 5 min gap)
  - Filters out soft-deleted events and non-session blocks
- **UI layer (SessionDetailModal.tsx):**
  - Added "Merge Session" button in ACTIONS section with Merge icon
  - Shows count of available neighbors ("N adjacent session(s) available")
  - Tapping Merge shows list of mergeable neighbors with details
  - Each neighbor shows title, time range, duration, intent-colored icon
  - Tapping a neighbor confirms merge action via Alert
  - Parent (ComprehensiveCalendarTemplate) passes allActualEvents prop
- **Learnings for future iterations:**
  - findMergeableNeighbors uses 5 min max gap (configurable) for adjacency
  - Merge combines ALL child events and summaries, not just visible top 3
  - Weighted confidence = sum(confidence * duration) / total duration
  - Same soft-delete pattern as split: meta.deleted_at + meta.deleted_reason

---

## 2026-01-29 - US-021
- **What was implemented:** Session split functionality allowing users to divide a session into two blocks
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/actual-ingestion.ts` (added splitSession, splitScheduledEventSession, SessionSplitResult interface, generateUserSessionSourceId)
  - `apps/mobile/src/lib/supabase/services/calendar-events.ts` (added splitSessionEvent, SplitSessionInput/Result interfaces, isEventSoftDeleted)
  - `apps/mobile/src/components/molecules/SessionDetailModal.tsx` (added split UI with time picker)
  - `apps/mobile/src/components/templates/ComprehensiveCalendarTemplate.tsx` (added dayStart and onSplit props)
- **Service layer (actual-ingestion.ts):**
  - `splitSession(session, splitPoint, childEvents?, userOverrides?)` - Core split logic
  - Redistributes child events based on midpoint time relative to split point
  - Recalculates intent for each new block using classifyIntent
  - Returns SessionSplitResult with firstSession, secondSession, originalSessionId
  - `splitScheduledEventSession` - Convenience wrapper for ScheduledEvent format
- **Database layer (calendar-events.ts):**
  - `splitSessionEvent(input)` - Persists split to database
  - Soft-deletes original by setting meta.deleted_at and meta.deleted_reason='split'
  - Creates two new events with meta.source='user' (protected from ingestion)
  - Links new events via meta.split_from to original event ID
  - `isEventSoftDeleted(meta)` - Helper to check if event was soft-deleted
- **UI layer (SessionDetailModal.tsx):**
  - Added "Split Session" button in ACTIONS section with Scissors icon
  - Session must be >= 10 minutes to split (validation)
  - Opens TimePickerModal with midpoint as initial time
  - Validates split point is within session bounds
  - Shows confirmation alert before executing split
  - Calls splitSessionEvent and notifies parent via onSplit callback
  - Parent (ComprehensiveCalendarTemplate) passes selectedDate as dayStart
- **Learnings for future iterations:**
  - Soft delete (meta.deleted_at) preferred over hard delete for audit trail
  - meta.source='user' protects events from being overwritten by ingestion
  - Intent type doesn't include 'commute' - use Intent type from app-categories.ts
  - TimePickerModal returns time for current day, adjust to session's day

---

## 2026-01-29 - US-020
- **What was implemented:** Session detail modal for viewing classification reasoning and app breakdown
- **Files changed:**
  - `apps/mobile/src/components/molecules/SessionDetailModal.tsx` (new)
  - `apps/mobile/src/components/templates/ComprehensiveCalendarTemplate.tsx` (modified)
- **SessionDetailModal features:**
  - Title section with session title and place label (MapPin icon)
  - Time range section showing start/end times and total duration
  - Classification section with intent badge (color-coded) and reasoning text
  - App usage breakdown with all apps showing duration, percentage, and progress bars
  - Location confidence indicator with percentage and color-coded bar (green/yellow/orange)
  - Warning banner for sessions during scheduled sleep time
- **ComprehensiveCalendarTemplate changes:**
  - Added import for SessionDetailModal
  - Added state: sessionDetailEvent, isSessionDetailVisible
  - Modified onPress handler for actual events to open SessionDetailModal for session_block events
  - Added SessionDetailModal render near EventEditorModal
- **UI patterns used:**
  - Same modal pattern as EventEditorModal (Animated backdrop/panel)
  - NativeWind className for styling (Tailwind CSS in React Native)
  - Intent colors matching CATEGORY_STYLES (intent_work=blue, intent_leisure=green, etc.)
- **Learnings for future iterations:**
  - Session detail modal provides read-only view, editing features (split/merge) will come in US-021/US-022
  - meta.intent_reasoning contains the classification explanation from classifyIntent
  - meta.confidence is 0-1 scale for location confidence
  - meta.during_scheduled_sleep indicates screen-time during sleep hours

---

## 2026-01-29 - US-019
- **What was implemented:** Calendar display updates to show session blocks as the primary display format
- **Files changed:**
  - `apps/mobile/src/lib/calendar/actual-display-events.ts` (modified)
  - `apps/mobile/src/components/templates/ComprehensiveCalendarTemplate.tsx` (modified)
  - `apps/mobile/src/stores/events-store.ts` (modified)
- **Key changes to actual-display-events.ts:**
  - Added `sessionBlockChildIds` Set to collect child event IDs from session blocks
  - Updated `filteredActualEvents` to keep session_block events and hide their children
  - Child events are hidden by matching event.id or meta.source_id against session children
- **Key changes to ComprehensiveCalendarTemplate.tsx:**
  - Added intent-based style keys: intent_work (blue), intent_leisure (green), intent_distracted_work (orange), intent_sleep (purple), intent_offline (gray), intent_mixed (yellow), commute (gray)
  - Added `getSessionBlockStyleKey(event)` function to map session block intents to style keys
  - Added `buildSessionBlockSubtitle(event)` function to format top 3 apps as "App 15m · App2 10m" subtitle
  - Updated `TimeEventBlock` to:
    - Use intent-based styles for session blocks
    - Show MapPin icon for session blocks with place_label
    - Display session subtitle with top apps and durations
- **Key changes to events-store.ts (CalendarEventMeta type):**
  - Added to `kind` union: "session_block", "location_block", "commute"
  - Added session block fields: place_id, place_label, intent (work/leisure/distracted_work/offline/mixed/sleep/commute), children, summary, intent_reasoning, during_scheduled_sleep
- **Learnings for future iterations:**
  - Session blocks use meta.kind = 'session_block' to identify them
  - Child events referenced in meta.children array (can be event IDs or source_ids)
  - Intent maps to color: work=blue, leisure=green, distracted=orange, sleep=purple, offline/commute=gray
  - Use CalendarEventMeta type directly (no need for Record<string, unknown> cast)

---

## 2026-01-29 - US-018
- **What was implemented:** useActualIngestion hook for the new immutable ingestion pipeline
- **Files changed:**
  - `apps/mobile/src/lib/supabase/hooks/use-actual-ingestion.ts` (new)
  - `apps/mobile/src/lib/supabase/hooks/index.ts` (modified - added export)
- **Types created:**
  - `IngestionWindowResult` - Interface with skipped, reason, stats, error fields
  - `IngestionStats` - Interface tracking eventsCreated, eventsExtended, eventsUpdated, eventsDeleted, sessionsCreated, screenTimeSessions, locationSegments
- **Hook API:**
  - `processWindow(windowStart, windowEnd, sleepSchedule?)` - Process a single 30-minute window
  - `processWindows(windows[], sleepSchedule?)` - Process multiple windows in sequence
  - `getCurrentWindow()` - Get the current 30-min aligned window
  - `getPreviousWindow()` - Get the previous window (the one to process)
  - `isProcessing` - State indicating if processing is in progress
  - `lastResult` - Last processing result
- **Pipeline steps implemented:**
  1. Check if window is locked (skip if already processed)
  2. Parallel fetch: screen-time sessions, location samples, user places, app overrides, existing events, extension candidates
  3. Generate derived events: screenTimeToDerivedEvents, generateLocationSegments + processSegmentsWithCommutes
  4. Run computeReconciliationOpsWithPriority
  5. Execute reconciliation ops (extensions, inserts, updates, deletes)
  6. Run sessionizeWindow + applySleepDetection
  7. Insert session blocks as events
  8. Lock events in window + lock window
- **Key design decisions:**
  - Graceful error handling for all lock operations (non-fatal)
  - Stats logging in __DEV__ mode
  - Window alignment to 30-minute boundaries (00, 30)
  - User app category overrides converted from EventCategory to AppCategory
  - All operations use tmSchema() pattern for tm schema access
- **Learnings for future iterations:**
  - Hook doesn't have useCalendarEvents hook, so fetches screen-time sessions via fetchScreenTimeSessionsForDay
  - User app overrides need conversion from EventCategory (work, exercise, relationship, growth, routine) to AppCategory (work, social, entertainment, comms, utility, ignore)
  - 30-min window boundaries calculated from current time using setMinutes(0/30, 0, 0)

---

## 2026-01-29 - US-017
- **What was implemented:** Sleep session detection for overnight gaps at home
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/actual-ingestion.ts` (modified)
  - `apps/mobile/src/lib/supabase/services/actual-ingestion.test.ts` (modified)
  - `apps/mobile/src/lib/supabase/services/app-categories.ts` (modified)
- **Types created:**
  - `SleepSchedule` - Interface with bedtime and wakeTime strings (HH:MM format)
  - `SleepDetectionResult` - Interface with isSleep, sleepSessions, screenTimeInterruptions
  - Added `"sleep"` to the `Intent` union type
  - Added `during_scheduled_sleep?: boolean` to SessionBlock.meta
- **Constants created:**
  - `DEFAULT_SLEEP_SCHEDULE` - { bedtime: "22:00", wakeTime: "07:00" }
  - `MIN_SLEEP_DURATION_MS` - 4 hours
  - `MIN_OVERNIGHT_GAP_MS` - 3 hours
  - `HOME_PLACE_LABELS` - ["home", "house", "apartment", "residence", "my place"]
- **Functions created:**
  - `isHomePlace(placeLabel)` - Check if label matches home-like names
  - `isWithinSleepSchedule(timestamp, schedule)` - Check if time falls within sleep hours
  - `createSleepSession(start, end, placeId, placeLabel, windowStart, childEventIds, confidence)` - Create sleep session block
  - `detectSleepSessions(userId, windowStart, windowEnd, events, homePlace, schedule)` - Detect sleep and split around screen-time
  - `applySleepDetection(userId, sessions, windowStart, windowEnd, homePlace, schedule)` - Apply sleep detection to existing sessions
  - `findHomePlace(userPlaces)` - Find home place by category or label
- **Key design decisions:**
  - Uses UTC hours for time comparison (consistent with ISO date strings)
  - Sleep must be at home (matches by placeId or placeLabel)
  - Overnight gaps >= 3 hours at home during sleep schedule = sleep session
  - Screen-time interruptions during sleep split the sleep session
  - Screen-time blocks during sleep get `meta.during_scheduled_sleep = true`
  - Offline sessions at home during sleep hours are converted to sleep sessions
- **Tests added:** 19 tests in actual-ingestion.test.ts (38 total):
  - `isHomePlace`: 3 tests (home label, variations, non-home)
  - `isWithinSleepSchedule`: 3 tests (overnight, outside hours, same-day)
  - `createSleepSession`: 2 tests (properties, null label)
  - `detectSleepSessions`: 4 tests (no events, interruptions, not at home, daytime)
  - `applySleepDetection`: 4 tests (convert offline, mark during_sleep, keep existing, outside hours)
  - `findHomePlace`: 3 tests (by category, by label, not found)
- **Learnings for future iterations:**
  - Use `getUTCHours()` for time comparisons with ISO date strings
  - Home detection prioritizes category over label matching
  - Sleep detection requires both home place AND scheduled sleep time window
  - applySleepDetection is the main entry point for post-processing sessions

---

## 2026-01-29 - US-016
- **What was implemented:** Session summary generation for session blocks (verified existing implementation)
- **Files changed:**
  - None - functionality was already implemented in US-014's createSessionBlock function
- **Key verification:**
  - `meta.summary` is an array of `{ label: string, seconds: number }` (line 1006 in SessionBlock interface)
  - Summary contains top 3 apps by duration (`.slice(0, 3)` at line 1281)
  - Summary calculated from child events via `buildAppSummary` (lines 1120-1139)
  - `meta.intent` stored from `classifyIntent()` result (line 1310)
  - `meta.confidence` stored from location data (lines 1252-1268, stored at line 1312)
  - Tests in actual-ingestion.test.ts verify summary combining when merging sessions
- **Learnings for future iterations:**
  - Session summary generation was implemented as part of US-014's createSessionBlock function
  - buildAppSummary aggregates screen-time by app_id from child events
  - Summary format matches acceptance criteria: `{ label: string, seconds: number }`

---

## 2026-01-29 - US-015
- **What was implemented:** Micro-gap merging and short session absorption in sessionization
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/actual-ingestion.ts` (modified)
  - `apps/mobile/src/lib/supabase/services/actual-ingestion.test.ts` (new)
- **Constants added:**
  - `MAX_MICRO_GAP_MS` - 5 minutes (threshold for merging adjacent sessions)
  - `MIN_SESSION_DURATION_MS` - 10 minutes (threshold for absorbing short sessions)
- **Functions created:**
  - `mergeSessionMicroGaps(sessions, windowStart, userOverrides)` - Merges sessions with gaps < 5 minutes at the same place into a single session
  - `absorbShortSessions(sessions, windowStart, userOverrides)` - Absorbs sessions < 10 minutes into adjacent sessions at the same place
  - `mergeSessionBlocks(first, second, windowStart, userOverrides)` - Combines two sessions by extending the first to include the second
  - `combineAppSummaries(first, second)` - Combines app usage summaries from two sessions for re-classification
  - `isSessionCommute(session)` - Helper to check if a session is a commute
- **Key design decisions:**
  - Micro-gap merging applies to gaps BETWEEN sessions at the same place
  - Events at the same place already form a single session initially (not split by gaps)
  - Short session absorption uses iterative approach - keeps absorbing until no changes
  - Absorbs into preceding session first, then following if no preceding available
  - Commute sessions are never merged or absorbed regardless of duration
  - Combined sessions have re-calculated intent based on combined app summaries
  - Confidence is weighted average based on duration of original sessions
- **Updated `sessionizeWindow`:**
  - Now applies `mergeSessionMicroGaps` after initial grouping
  - Then applies `absorbShortSessions` to absorb short sessions
- **Tests added:** 19 tests in actual-ingestion.test.ts:
  - `mergeSessionMicroGaps`: 7 tests (single session, gap < 5 min, gap >= 5 min, different places, commutes, multiple gaps, summary combining)
  - `absorbShortSessions`: 7 tests (single session, absorb into prev, absorb into next, different places, commutes, long sessions, iterative absorption)
  - `sessionizeWindow with micro-gap merging`: 5 tests (3-min gap, 6-min gap different places, short absorption, different places, commutes)
- **Learnings for future iterations:**
  - Events at the same place form one session regardless of gaps - micro-gap merging is for session-level gaps
  - Use `isSessionCommute` helper to identify commute sessions (checks intent and title)
  - Absorption is iterative - may require multiple passes if multiple short sessions

---

## 2026-01-29 - US-014
- **What was implemented:** Sessionization pass for grouping granular events by location into place-anchored session blocks
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/actual-ingestion.ts` (modified)
- **Types created:**
  - `SessionBlock` - Interface for session blocks with meta.kind = 'session_block', title, placeId, intent, childEventIds, confidence
  - `SessionizableEvent` - Interface for input events that can be sessionized (ReconciliationEvent, DerivedEvent, or generic)
- **Functions created:**
  - `sessionizeWindow(userId, windowStart, windowEnd, events, userOverrides)` - Main entry point that groups events by location and creates session blocks
  - `sessionBlockToDerivedEvent(session)` - Converts SessionBlock to DerivedEvent for reconciliation
  - `groupEventsByLocation(events)` - Groups events into arrays by location context (place changes = boundary)
  - `createSessionBlock(events, windowStart, userOverrides)` - Creates a single SessionBlock from grouped events
  - `buildAppSummary(events)` - Aggregates screen-time by app_id for intent classification
  - `generateSessionTitle(placeLabel, intent, isCommute)` - Creates title in format '[Place] - [Intent]'
  - `generateSessionSourceId(windowStart, placeId, sessionStart)` - Creates deterministic source_id: session:{windowStartMs}:{placeId}:{sessionStartMs}
- **Helper functions:**
  - `getEventPlaceId(event)` - Extract place_id from event meta
  - `getEventPlaceLabel(event)` - Extract place_label from event meta
  - `getEventIdentifier(event)` - Get id or sourceId for child linking
  - `isScreenTimeEvent(event)` - Check if event has app_id
  - `isEventCommute(event)` - Check if event is a commute
  - `haveSameLocationContext(event1, event2)` - Check if two events share location context
  - `formatIntentForTitle(intent)` - Capitalize intent for title display
- **Key design decisions:**
  - Session boundaries created when place_id changes or commute event occurs
  - Commute events form their own sessions with intent = 'offline'
  - Session title format: '[Place] - [Intent]' (e.g., 'Cafe - Work', 'Home - Leisure')
  - Child events linked via meta.children array of event identifiers
  - Intent classification uses classifyIntent from app-categories.ts
  - meta.kind = 'session_block' for easy filtering in UI
  - Top 3 apps stored in meta.summary for display
  - Confidence inherited from location evidence
- **Learnings for future iterations:**
  - SessionBlock structure ready for US-016 (session summary generation)
  - sessionizeWindow filters events to window boundaries before processing
  - Child events can be either database IDs or derived event sourceIds
  - Use sessionBlockToDerivedEvent to convert for reconciliation pipeline

---

## 2026-01-29 - US-013
- **What was implemented:** Intent classification algorithm for session categorization
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/app-categories.ts` (modified)
  - `apps/mobile/src/lib/supabase/services/app-categories.test.ts` (new)
- **Types created:**
  - `Intent` - Type for session intents: "work" | "leisure" | "distracted_work" | "offline" | "mixed"
  - `AppSummary` - Interface for app usage summary with appId, seconds, and optional category
  - `IntentClassificationResult` - Interface with intent, breakdown by category, totalSeconds, and reasoning
- **Constants created:**
  - `INTENT_THRESHOLDS` - Configuration for classification thresholds:
    - WORK_HIGH: 0.6 (60% for work classification)
    - WORK_MEDIUM_MIN: 0.4 (40% min for distracted_work)
    - WORK_MEDIUM_MAX: 0.6 (60% max for distracted_work)
    - LEISURE_HIGH: 0.6 (60% for leisure classification)
    - SOCIAL_DISTRACTION: 0.25 (25% social threshold for distracted_work)
- **Functions created:**
  - `classifyIntent(screenTimeSummary, userOverrides)` - Main function that classifies session intent based on app usage percentages
  - `classifyIntentSimple(screenTimeSummary, userOverrides)` - Simplified version that returns just the intent string
- **Key design decisions:**
  - Classification rules applied in priority order: work → leisure → distracted_work → mixed
  - Ignored apps (system processes) excluded from percentage calculations
  - Pre-computed categories supported via optional category field in AppSummary
  - Returns full breakdown with human-readable reasoning for UI display
  - Integrates with existing getAppCategory for category lookup
- **Tests added:** 31 tests in app-categories.test.ts covering:
  - getAppCategory: 6 tests (existing behavior verification)
  - isWorkCategory/isLeisureCategory: 4 tests
  - classifyIntent: 17 tests for all classification rules
  - classifyIntentSimple: 2 tests
  - INTENT_THRESHOLDS: 1 test
- **Learnings for future iterations:**
  - Use classifyIntent for sessionization pass (US-014) to determine session intent
  - IntentClassificationResult.reasoning can be shown to users to explain why their session was classified a certain way
  - INTENT_THRESHOLDS are exported for potential UI configuration in the future

---

## 2026-01-29 - US-012
- **What was implemented:** Default app category mapping for intent classification
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/app-categories.ts` (new)
- **Types created:**
  - `AppCategory` - Type for app categories: "work" | "social" | "entertainment" | "comms" | "utility" | "ignore"
  - `UserAppCategoryOverride` - Interface for user overrides with category and optional confidence
  - `UserAppCategoryOverrides` - Map type for user overrides keyed by normalized app name
- **Constants created:**
  - `DEFAULT_APP_CATEGORIES` - Record<string, AppCategory> mapping 100+ apps to their categories:
    - Work (50+ apps): Slack, Gmail, Zoom, VS Code, Figma, Notion, Linear, Teams, GitHub, etc.
    - Social (20+ apps): Instagram, TikTok, X/Twitter, Reddit, Facebook, LinkedIn, Discord, etc.
    - Entertainment (40+ apps): YouTube, Netflix, Spotify, Apple Music, Podcasts, Disney+, games, etc.
    - Comms (20+ apps): Messages, WhatsApp, Telegram, Signal, Phone, FaceTime, etc.
    - Utility (40+ apps): Maps, Photos, Weather, Calculator, Settings, browsers, etc.
    - Ignore (15+ apps): System processes like SpringBoard, Siri, Control Center
- **Functions created:**
  - `getAppCategory(appId, userOverrides)` - Main function that returns app category, checking user overrides first, then defaults with exact + partial matching
  - `isWorkCategory(category)` - Check if category is "work"
  - `isLeisureCategory(category)` - Check if category is "social" or "entertainment"
  - `getAppsByCategory(category)` - Get all default apps in a specific category
- **Key design decisions:**
  - Reuses `normalizeAppKey` from existing app-classification.ts for consistency
  - User overrides have highest priority
  - Partial matching as fallback (app name contains or is contained by known key)
  - Unknown apps default to "utility" (better for intent calculation than "unknown")
  - Separate from EventCategory - this is specifically for intent classification
- **Learnings for future iterations:**
  - Use getAppCategory for intent classification (US-013)
  - User override integration works with existing user-app-categories.ts service
  - Categories align with those in tm.user_app_categories table CHECK constraint

---

## 2026-01-29 - US-011
- **What was implemented:** Priority-based reconciliation for location and screen-time events
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.ts` (modified)
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.test.ts` (modified)
- **Functions created:**
  - `getEventPriority(event)` - Get the priority level of a reconciliation event (protected > screen_time > location > unknown)
  - `getDerivedEventPriority(event)` - Get the priority level of a derived event
  - `trimEventToGaps(event, higherPriorityEvents)` - Trim a derived event to fill only gaps not covered by higher-priority events
  - `computeReconciliationOpsWithPriority(existingEvents, screenTimeEvents, locationEvents, previousWindowEvents)` - Main reconciliation function with priority handling
- **Types created:**
  - `EventPriority` - Type for priority levels: "protected" | "screen_time" | "location" | "unknown"
- **Key design decisions:**
  - Priority order: protected (4) > screen_time (3) > location (2) > unknown (1)
  - Screen-time events processed first, then location events fill remaining gaps
  - Location blocks are trimmed/split around screen-time events
  - Commute blocks are NOT trimmed - they act as containers that can have screen-time inside
  - Protected events block both screen-time and location from inserting
  - Short location gaps (< 1 min) are filtered out to avoid fragmentation
  - Extension logic still works for both screen-time and location events from previous windows
- **Tests added:** 25 new tests (73 total in file)
  - getEventPriority: 6 tests for all priority levels
  - getDerivedEventPriority: 2 tests
  - trimEventToGaps: 6 tests for gap detection and event splitting
  - computeReconciliationOpsWithPriority: 11 tests covering priority scenarios, extensions, and edge cases
- **Learnings for future iterations:**
  - computeReconciliationOpsWithPriority is the main entry point for reconciliation in the actual ingestion pipeline
  - Screen-time events are passed separately from location events for clear priority handling
  - Commute events need special handling - they should coexist with screen-time events (not be trimmed)
  - The trimEventToGaps function handles splitting events into multiple parts around higher-priority events

---

## 2026-01-29 - US-010
- **What was implemented:** Trailing edge extension for location events
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.ts` (modified)
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.test.ts` (modified)
- **Functions created:**
  - `findExtendableLocationEvent(existingEvents, windowStart, placeId)` - Finds the most recent location event ending near window start with matching place_id
  - `canExtendLocationEvent(derived, existing)` - Check if derived location event can extend an existing location event
  - `computeReconciliationOpsWithLocationExtension(existingEvents, derivedEvents, previousWindowEvents)` - Reconciliation with location extension support
- **Helpers added:**
  - `getPlaceId(event)` - Extract place_id from event meta
  - `isLocationEvent(event)` - Check if event has meta.kind = 'location_block' or 'commute'
- **Key design decisions:**
  - Extension gap threshold: 60 seconds (same as screen-time extension)
  - Matches place_id including null for unknown locations (continuous unknown locations can extend)
  - Only the most recent location event is extended (not multiple)
  - Locked events cannot be extended (protected)
  - Handles mixed location and screen-time events in the same reconciliation pass
- **Tests added:** 19 new tests (48 total in file)
  - findExtendableLocationEvent: 7 tests for gap/place matching including null place_id
  - canExtendLocationEvent: 6 tests for gap threshold, place matching, and event type validation
  - computeReconciliationOpsWithLocationExtension: 6 tests for continuous sessions, place changes, gaps, and locked events
- **Learnings for future iterations:**
  - Location extension follows same pattern as screen-time extension (US-006)
  - Unknown locations (null place_id) can be extended if they're consecutive
  - The computeReconciliationOpsWithLocationExtension function handles both location and screen-time extensions in one pass
  - Use isLocationEvent helper to distinguish location events from screen-time events

---

## 2026-01-29 - US-009
- **What was implemented:** Commute detection for actual ingestion pipeline
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/actual-ingestion.ts` (modified)
- **Functions created:**
  - `detectCommute(locationSamples, startTime, endTime, userPlaces)` - Main function that identifies movement between places
  - `createCommuteSegment(commute, windowStart)` - Creates a LocationSegment with meta.kind='commute' for long commutes
  - `applyTravelAnnotations(segments, commutes)` - Adds meta.travel_annotation to segments following short commutes
  - `processSegmentsWithCommutes(segments, locationSamples, userPlaces, windowStart)` - Main entry point combining segments with commute detection
  - `isMovementGroup(samples, userPlaces)` - Checks if samples represent movement (2+ places or >200m distance)
  - `calculatePathDistance(samples)` - Calculates total path distance using haversine
  - `findBoundaryPlaces(samples, userPlaces)` - Finds first and last stable place for commute origin/destination
  - `generateCommuteSourceId(windowStart, segmentStart)` - Creates deterministic source_id for commute segments
- **Types created/updated:**
  - `CommuteDetectionResult` - Exported interface with isCommute, durationMs, isLongCommute, travelAnnotation, fromPlace, toPlace, distanceM, samples
  - `LocationSegment.meta.kind` - Updated to union type `"location_block" | "commute"`
  - `LocationSegment.meta` - Added optional fields: intent, travel_annotation, destination_place_id, destination_place_label, distance_m
- **Key design decisions:**
  - MIN_COMMUTE_DURATION_MS = 10 minutes (threshold for separate commute segment)
  - MIN_COMMUTE_DISTANCE_M = 200m (minimum distance to consider movement)
  - Movement detection: 2+ unique places matched OR >200m total path distance
  - Short commutes (<10min) add travel_annotation to the next location segment
  - Long commutes (>=10min) create separate segment with meta.intent = 'commute'
  - Commute source ID format: `commute:{windowStartMs}:{segmentStartMs}`
  - segmentsToDerivedEvents updated to use "Commute" title for commute segments
- **Learnings for future iterations:**
  - Commute detection is separate from location segment generation for clarity
  - processSegmentsWithCommutes is the main entry point that combines both
  - Travel annotations are applied in-place to segments array
  - Boundary places found by first/last matched place in commute samples

---

## 2026-01-29 - US-008
- **What was implemented:** Location segment generation for actual ingestion pipeline
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/actual-ingestion.ts` (new)
- **Functions created:**
  - `generateLocationSegments(locationSamples, userPlaces, windowStart, windowEnd)` - Main function that converts raw GPS samples into contiguous place blocks
  - `mergeAdjacentSegments(segments, maxGapMs)` - Merge adjacent segments with same place (handles GPS drift)
  - `segmentsToDerivedEvents(segments)` - Convert segments to DerivedEvent format for reconciliation
  - `findMatchingPlace(latitude, longitude, userPlaces)` - Match coordinates to user places using haversine distance
  - `findDominantPlace(samples, userPlaces)` - Find the dominant place for a group of samples (70%+ threshold)
  - `calculateCentroid(samples)` - Calculate average coordinates for a segment
  - `generateSourceId(windowStart, placeId, segmentStart)` - Create deterministic source_id
  - `calculateSegmentConfidence(sampleCount, placeMatchRatio)` - Calculate confidence score 0-1
- **Types created:**
  - `LocationSegment` - Exported interface for location blocks with meta.kind = 'location_block'
  - `SampleGroup` - Internal type for grouping samples during segmentation
- **Key design decisions:**
  - DEFAULT_PLACE_RADIUS_M = 150m (matches PostGIS ST_DWithin behavior)
  - PLACE_MATCH_THRESHOLD = 0.7 (70% of samples must match for place assignment)
  - Haversine distance for coordinate matching (Earth-accurate, ~1m precision)
  - Source ID format: `location:{windowStartMs}:{placeId}:{segmentStartMs}` for deterministic reconciliation
  - Segment boundaries clamped to window boundaries
  - Confidence = sample count contribution (0.3-0.6) + place match bonus (0-0.4)
- **Learnings for future iterations:**
  - Reuse haversine distance function from evidence-data.ts rather than reimplementing (kept for now for locality)
  - Location segment generation is separate from commute detection (US-009) for clarity
  - mergeAdjacentSegments handles GPS drift scenarios
  - segmentsToDerivedEvents creates proper meta structure for reconciliation pipeline

---

## 2026-01-29 - US-007
- **What was implemented:** fetchLocationEvidenceForWindow function for ingestion pipeline
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/evidence-data.ts` (modified)
- **Functions created:**
  - `fetchLocationEvidenceForWindow(userId, windowStart, windowEnd)` - Main function that combines all location data sources
  - `fetchLocationSamplesForWindow(userId, windowStart, windowEnd)` - Query raw GPS points in time window
  - `fetchLocationHourlyForWindow(userId, windowStart, windowEnd)` - Query aggregated hourly data with place joins
  - `haversineDistance(lat1, lon1, lat2, lon2)` - Calculate distance between two coordinates in meters
  - `findMatchingPlace(latitude, longitude, userPlaces)` - Find best matching user place using haversine (ST_DWithin equivalent)
  - `calculateConfidence(sampleCount, avgAccuracyM)` - Calculate confidence score 0-1 based on data quality
  - `buildLocationEvidence(samples, hourlyData, userPlaces, windowStart, windowEnd)` - Combine data into LocationEvidence array
  - `createEvidenceFromSegment(segment, windowStart, windowEnd)` - Create single LocationEvidence from sample segment
- **Types created:**
  - `LocationEvidence` - Exported interface with start, end, place_id, place_label, latitude, longitude, confidence
  - `WindowLocationSample` - Internal type for raw location samples
- **Key design decisions:**
  - Raw samples preferred over hourly aggregates for precise timestamps
  - Groups consecutive samples by matching place to create segments
  - Falls back to hourly aggregates when no raw samples available
  - Haversine distance used client-side to replicate ST_DWithin database behavior
  - Confidence calculation: 0.3-0.7 base from sample count (up to 10 samples), +0.3 accuracy bonus (<20m excellent, <50m good, <100m okay)
  - Segment boundaries clamped to window boundaries
- **Learnings for future iterations:**
  - Reuse existing `fetchUserPlaces` function rather than reimplementing
  - Hour boundaries for hourly query expanded to capture overlapping hours (floor start, ceil end)
  - LocationEvidence segments match consecutive samples with same place_id (including null for unknown)
  - Pre-existing typecheck error at line 438 (healthDaily: [] should be null) is unrelated to this change

---

## 2026-01-29 - US-006
- **What was implemented:** Trailing edge extension for screen-time sessions
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.ts` (modified)
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.test.ts` (modified)
- **Functions created:**
  - `findExtendableEvent(existingEvents, windowStart, appId)` - Finds the most recent event ending near window start with matching app_id
  - `computeReconciliationOpsWithExtension(existingEvents, derivedEvents, previousWindowEvents)` - Reconciliation with extension support
  - `canExtendEvent(derived, existing)` - Check if derived event can extend an existing event
  - `fetchExtensionCandidates(userId, windowStart)` - Database query for extension candidates
  - `extendEvent(eventId, newEnd)` - Update event's scheduled_end
  - `executeExtensions(extensions)` - Execute all extension operations from ReconciliationOps
- **Key design decisions:**
  - Extension gap threshold: 60 seconds (events ending within 60s of window start can be extended)
  - Only the most recent event is extended (not multiple)
  - Different app_id creates separate events
  - Locked events cannot be extended (protected)
  - Extension creates "extend" operation type in ReconciliationOps
- **Tests added:** 17 new tests (29 total in file)
  - findExtendableEvent: 6 tests for gap/app matching
  - canExtendEvent: 5 tests for gap threshold and app matching
  - computeReconciliationOpsWithExtension: 6 tests for continuous sessions, gaps, and locked events
- **Learnings for future iterations:**
  - Extension logic is separate from core reconciliation for clarity
  - Use EXTENSION_GAP_THRESHOLD_MS constant (60s) for configurable threshold
  - ExtendableEvent type added but not yet used (for future database operations)
  - Extension candidates fetched from previous window, not current window

---

## 2026-01-29 - US-005
- **What was implemented:** Event reconciliation service with locked event protection
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.ts` (new)
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.test.ts` (new)
- **Functions created:**
  - `computeReconciliationOps(existingEvents, derivedEvents)` - Computes inserts/updates/deletes while protecting locked events
  - `fetchEventsInWindow(userId, windowStart, windowEnd)` - Fetch events with locked_at status
  - `lockEventsInWindow(userId, windowStart, windowEnd)` - Set locked_at on all events in window
  - `hasLockedEventsInWindow(userId, windowStart, windowEnd)` - Check if any events are locked
  - `getLockedEventsInRange(userId, startTime, endTime)` - Get all locked events in range
- **Key design decisions:**
  - Locked events (locked_at IS NOT NULL) cannot be deleted or modified
  - User-edited events (source = 'user' or 'actual_adjust') protected from deletion even if unlocked
  - Derived events matched by source_id, can be updated if times change
  - New inserts skipped if they would overlap with protected events
- **Learnings for future iterations:**
  - Handle missing locked_at column gracefully (for pre-migration compatibility)
  - Use lockedAt: null vs undefined to distinguish "not locked" from "column doesn't exist"
  - Tests cover all 6 acceptance criteria scenarios
  - Pre-existing typecheck errors in codebase don't affect new service files
  - Types: ReconciliationEvent, DerivedEvent, ReconciliationOp, ReconciliationOps

---

## 2026-01-29 - US-004
- **What was implemented:** Window lock service for actual ingestion pipeline
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/actual-ingestion-window-locks.ts` (new)
- **Functions created:**
  - `isWindowLocked(userId, windowStart)` - Check if window is already processed
  - `lockWindow({ userId, windowStart, windowEnd, stats })` - Mark window as processed with stats
  - `processIngestionWindow({ userId, windowStart, windowEnd, process })` - Wrapper that checks lock, runs callback, then locks
  - `getWindowLock(userId, windowStart)` - Get lock record details
  - `getLockedWindowsInRange(userId, startTime, endTime)` - Get all locked windows in range
  - `checkWindowLockBeforeProcessing(userId, windowStart)` - Returns { skipped: true } if locked
- **Learnings for future iterations:**
  - Follow data-sync-state.ts pattern for service structure
  - Use `maybeSingle()` for queries that may return 0 or 1 rows
  - Handle missing table errors gracefully (for new tables not yet migrated)
  - Use `__DEV__` guard for development-only console warnings
  - Upsert with `onConflict` uses column names without prefix (e.g., `"user_id,window_start"`)
  - Types: WindowLock, WindowLockStats, WindowLockInsert, ProcessIngestionWindowResult

---

## 2026-01-29 - US-003
- **What was implemented:** Added CHECK constraint for category values to existing tm.user_app_categories table
- **Files changed:**
  - `supabase/migrations/20260129_user_app_categories_check_constraint.sql` (new)
- **Learnings for future iterations:**
  - The tm.user_app_categories table already existed (created in 20260119_user_app_categories_learning.sql)
  - When a table already exists, add only what's missing (e.g., constraints, indexes)
  - CHECK constraints for allowed category values: work, social, entertainment, comms, utility, ignore
  - Use DO blocks with pg_constraint checks for idempotent constraint creation
  - Column `app_key` in existing table serves same purpose as PRD's `app_id` - no need to rename

---

## 2026-01-29 - US-002
- **What was implemented:** Added locked_at column to tm.events table
- **Files changed:**
  - `supabase/migrations/20260129_add_locked_at_to_tm_events.sql` (new)
- **Learnings for future iterations:**
  - ALTER TABLE with ADD COLUMN IF NOT EXISTS is idempotent
  - Partial indexes use WHERE clause to only index non-null rows - more efficient for sparse columns
  - Column comments are useful for documentation in database schema
  - Existing typecheck errors in mobile app don't affect SQL migrations

---

## 2026-01-29 - US-001
- **What was implemented:** Created tm.actual_ingestion_window_locks table migration
- **Files changed:**
  - `supabase/migrations/20260129_create_tm_actual_ingestion_window_locks.sql` (new)
- **Learnings for future iterations:**
  - Migration follows established pattern with idempotent DDL
  - Table uses same FK pattern to auth.users(id) as other tm tables
  - UNIQUE constraint on (user_id, window_start) ensures idempotent lock operations
  - Index on (user_id, window_start) for fast lock lookups
  - RLS policies for select/insert allow users to manage their own locks
  - Pre-existing typecheck errors in mobile app are unrelated to migrations

---

