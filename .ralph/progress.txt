# Ralph Progress Log
# Feature: Location-Informed Actual Ingestion with Sessionization
# Branch: ralph/location-informed-actual-ingestion
# Started: 2026-01-29

## Codebase Patterns
- Migration naming: `YYYYMMDD_description_of_migration.sql` in `supabase/migrations/`
- All tm schema tables use `user_id uuid NOT NULL references auth.users(id) on delete cascade`
- Idempotent SQL: Use `create table if not exists`, `create index if not exists`
- RLS policy creation uses DO blocks with pg_policies checks for idempotency
- Triggers for updated_at use `public.update_updated_at_column()` function
- Grants: `grant usage on schema tm to authenticated; grant select, insert, update, delete on tm.table to authenticated;`
- TypeScript pre-existing errors in codebase - not blocking for SQL migrations
- Services pattern: Use `tmSchema()` helper function for `supabase.schema("tm")` access
- Error handling: Use `handleSupabaseError()` wrapper and graceful fallbacks for missing tables
- Location segments: Use haversineDistance for coordinate matching, LocationSegment interface for event creation
- Commute detection: Movement = 2+ unique places OR >200m total distance; 10min threshold for separate segment
- Reconciliation priority: protected (4) > screen_time (3) > location (2) > unknown (1); use computeReconciliationOpsWithPriority for final reconciliation

---

## 2026-01-29 - US-013
- **What was implemented:** Intent classification algorithm for session categorization
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/app-categories.ts` (modified)
  - `apps/mobile/src/lib/supabase/services/app-categories.test.ts` (new)
- **Types created:**
  - `Intent` - Type for session intents: "work" | "leisure" | "distracted_work" | "offline" | "mixed"
  - `AppSummary` - Interface for app usage summary with appId, seconds, and optional category
  - `IntentClassificationResult` - Interface with intent, breakdown by category, totalSeconds, and reasoning
- **Constants created:**
  - `INTENT_THRESHOLDS` - Configuration for classification thresholds:
    - WORK_HIGH: 0.6 (60% for work classification)
    - WORK_MEDIUM_MIN: 0.4 (40% min for distracted_work)
    - WORK_MEDIUM_MAX: 0.6 (60% max for distracted_work)
    - LEISURE_HIGH: 0.6 (60% for leisure classification)
    - SOCIAL_DISTRACTION: 0.25 (25% social threshold for distracted_work)
- **Functions created:**
  - `classifyIntent(screenTimeSummary, userOverrides)` - Main function that classifies session intent based on app usage percentages
  - `classifyIntentSimple(screenTimeSummary, userOverrides)` - Simplified version that returns just the intent string
- **Key design decisions:**
  - Classification rules applied in priority order: work → leisure → distracted_work → mixed
  - Ignored apps (system processes) excluded from percentage calculations
  - Pre-computed categories supported via optional category field in AppSummary
  - Returns full breakdown with human-readable reasoning for UI display
  - Integrates with existing getAppCategory for category lookup
- **Tests added:** 31 tests in app-categories.test.ts covering:
  - getAppCategory: 6 tests (existing behavior verification)
  - isWorkCategory/isLeisureCategory: 4 tests
  - classifyIntent: 17 tests for all classification rules
  - classifyIntentSimple: 2 tests
  - INTENT_THRESHOLDS: 1 test
- **Learnings for future iterations:**
  - Use classifyIntent for sessionization pass (US-014) to determine session intent
  - IntentClassificationResult.reasoning can be shown to users to explain why their session was classified a certain way
  - INTENT_THRESHOLDS are exported for potential UI configuration in the future

---

## 2026-01-29 - US-012
- **What was implemented:** Default app category mapping for intent classification
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/app-categories.ts` (new)
- **Types created:**
  - `AppCategory` - Type for app categories: "work" | "social" | "entertainment" | "comms" | "utility" | "ignore"
  - `UserAppCategoryOverride` - Interface for user overrides with category and optional confidence
  - `UserAppCategoryOverrides` - Map type for user overrides keyed by normalized app name
- **Constants created:**
  - `DEFAULT_APP_CATEGORIES` - Record<string, AppCategory> mapping 100+ apps to their categories:
    - Work (50+ apps): Slack, Gmail, Zoom, VS Code, Figma, Notion, Linear, Teams, GitHub, etc.
    - Social (20+ apps): Instagram, TikTok, X/Twitter, Reddit, Facebook, LinkedIn, Discord, etc.
    - Entertainment (40+ apps): YouTube, Netflix, Spotify, Apple Music, Podcasts, Disney+, games, etc.
    - Comms (20+ apps): Messages, WhatsApp, Telegram, Signal, Phone, FaceTime, etc.
    - Utility (40+ apps): Maps, Photos, Weather, Calculator, Settings, browsers, etc.
    - Ignore (15+ apps): System processes like SpringBoard, Siri, Control Center
- **Functions created:**
  - `getAppCategory(appId, userOverrides)` - Main function that returns app category, checking user overrides first, then defaults with exact + partial matching
  - `isWorkCategory(category)` - Check if category is "work"
  - `isLeisureCategory(category)` - Check if category is "social" or "entertainment"
  - `getAppsByCategory(category)` - Get all default apps in a specific category
- **Key design decisions:**
  - Reuses `normalizeAppKey` from existing app-classification.ts for consistency
  - User overrides have highest priority
  - Partial matching as fallback (app name contains or is contained by known key)
  - Unknown apps default to "utility" (better for intent calculation than "unknown")
  - Separate from EventCategory - this is specifically for intent classification
- **Learnings for future iterations:**
  - Use getAppCategory for intent classification (US-013)
  - User override integration works with existing user-app-categories.ts service
  - Categories align with those in tm.user_app_categories table CHECK constraint

---

## 2026-01-29 - US-011
- **What was implemented:** Priority-based reconciliation for location and screen-time events
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.ts` (modified)
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.test.ts` (modified)
- **Functions created:**
  - `getEventPriority(event)` - Get the priority level of a reconciliation event (protected > screen_time > location > unknown)
  - `getDerivedEventPriority(event)` - Get the priority level of a derived event
  - `trimEventToGaps(event, higherPriorityEvents)` - Trim a derived event to fill only gaps not covered by higher-priority events
  - `computeReconciliationOpsWithPriority(existingEvents, screenTimeEvents, locationEvents, previousWindowEvents)` - Main reconciliation function with priority handling
- **Types created:**
  - `EventPriority` - Type for priority levels: "protected" | "screen_time" | "location" | "unknown"
- **Key design decisions:**
  - Priority order: protected (4) > screen_time (3) > location (2) > unknown (1)
  - Screen-time events processed first, then location events fill remaining gaps
  - Location blocks are trimmed/split around screen-time events
  - Commute blocks are NOT trimmed - they act as containers that can have screen-time inside
  - Protected events block both screen-time and location from inserting
  - Short location gaps (< 1 min) are filtered out to avoid fragmentation
  - Extension logic still works for both screen-time and location events from previous windows
- **Tests added:** 25 new tests (73 total in file)
  - getEventPriority: 6 tests for all priority levels
  - getDerivedEventPriority: 2 tests
  - trimEventToGaps: 6 tests for gap detection and event splitting
  - computeReconciliationOpsWithPriority: 11 tests covering priority scenarios, extensions, and edge cases
- **Learnings for future iterations:**
  - computeReconciliationOpsWithPriority is the main entry point for reconciliation in the actual ingestion pipeline
  - Screen-time events are passed separately from location events for clear priority handling
  - Commute events need special handling - they should coexist with screen-time events (not be trimmed)
  - The trimEventToGaps function handles splitting events into multiple parts around higher-priority events

---

## 2026-01-29 - US-010
- **What was implemented:** Trailing edge extension for location events
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.ts` (modified)
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.test.ts` (modified)
- **Functions created:**
  - `findExtendableLocationEvent(existingEvents, windowStart, placeId)` - Finds the most recent location event ending near window start with matching place_id
  - `canExtendLocationEvent(derived, existing)` - Check if derived location event can extend an existing location event
  - `computeReconciliationOpsWithLocationExtension(existingEvents, derivedEvents, previousWindowEvents)` - Reconciliation with location extension support
- **Helpers added:**
  - `getPlaceId(event)` - Extract place_id from event meta
  - `isLocationEvent(event)` - Check if event has meta.kind = 'location_block' or 'commute'
- **Key design decisions:**
  - Extension gap threshold: 60 seconds (same as screen-time extension)
  - Matches place_id including null for unknown locations (continuous unknown locations can extend)
  - Only the most recent location event is extended (not multiple)
  - Locked events cannot be extended (protected)
  - Handles mixed location and screen-time events in the same reconciliation pass
- **Tests added:** 19 new tests (48 total in file)
  - findExtendableLocationEvent: 7 tests for gap/place matching including null place_id
  - canExtendLocationEvent: 6 tests for gap threshold, place matching, and event type validation
  - computeReconciliationOpsWithLocationExtension: 6 tests for continuous sessions, place changes, gaps, and locked events
- **Learnings for future iterations:**
  - Location extension follows same pattern as screen-time extension (US-006)
  - Unknown locations (null place_id) can be extended if they're consecutive
  - The computeReconciliationOpsWithLocationExtension function handles both location and screen-time extensions in one pass
  - Use isLocationEvent helper to distinguish location events from screen-time events

---

## 2026-01-29 - US-009
- **What was implemented:** Commute detection for actual ingestion pipeline
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/actual-ingestion.ts` (modified)
- **Functions created:**
  - `detectCommute(locationSamples, startTime, endTime, userPlaces)` - Main function that identifies movement between places
  - `createCommuteSegment(commute, windowStart)` - Creates a LocationSegment with meta.kind='commute' for long commutes
  - `applyTravelAnnotations(segments, commutes)` - Adds meta.travel_annotation to segments following short commutes
  - `processSegmentsWithCommutes(segments, locationSamples, userPlaces, windowStart)` - Main entry point combining segments with commute detection
  - `isMovementGroup(samples, userPlaces)` - Checks if samples represent movement (2+ places or >200m distance)
  - `calculatePathDistance(samples)` - Calculates total path distance using haversine
  - `findBoundaryPlaces(samples, userPlaces)` - Finds first and last stable place for commute origin/destination
  - `generateCommuteSourceId(windowStart, segmentStart)` - Creates deterministic source_id for commute segments
- **Types created/updated:**
  - `CommuteDetectionResult` - Exported interface with isCommute, durationMs, isLongCommute, travelAnnotation, fromPlace, toPlace, distanceM, samples
  - `LocationSegment.meta.kind` - Updated to union type `"location_block" | "commute"`
  - `LocationSegment.meta` - Added optional fields: intent, travel_annotation, destination_place_id, destination_place_label, distance_m
- **Key design decisions:**
  - MIN_COMMUTE_DURATION_MS = 10 minutes (threshold for separate commute segment)
  - MIN_COMMUTE_DISTANCE_M = 200m (minimum distance to consider movement)
  - Movement detection: 2+ unique places matched OR >200m total path distance
  - Short commutes (<10min) add travel_annotation to the next location segment
  - Long commutes (>=10min) create separate segment with meta.intent = 'commute'
  - Commute source ID format: `commute:{windowStartMs}:{segmentStartMs}`
  - segmentsToDerivedEvents updated to use "Commute" title for commute segments
- **Learnings for future iterations:**
  - Commute detection is separate from location segment generation for clarity
  - processSegmentsWithCommutes is the main entry point that combines both
  - Travel annotations are applied in-place to segments array
  - Boundary places found by first/last matched place in commute samples

---

## 2026-01-29 - US-008
- **What was implemented:** Location segment generation for actual ingestion pipeline
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/actual-ingestion.ts` (new)
- **Functions created:**
  - `generateLocationSegments(locationSamples, userPlaces, windowStart, windowEnd)` - Main function that converts raw GPS samples into contiguous place blocks
  - `mergeAdjacentSegments(segments, maxGapMs)` - Merge adjacent segments with same place (handles GPS drift)
  - `segmentsToDerivedEvents(segments)` - Convert segments to DerivedEvent format for reconciliation
  - `findMatchingPlace(latitude, longitude, userPlaces)` - Match coordinates to user places using haversine distance
  - `findDominantPlace(samples, userPlaces)` - Find the dominant place for a group of samples (70%+ threshold)
  - `calculateCentroid(samples)` - Calculate average coordinates for a segment
  - `generateSourceId(windowStart, placeId, segmentStart)` - Create deterministic source_id
  - `calculateSegmentConfidence(sampleCount, placeMatchRatio)` - Calculate confidence score 0-1
- **Types created:**
  - `LocationSegment` - Exported interface for location blocks with meta.kind = 'location_block'
  - `SampleGroup` - Internal type for grouping samples during segmentation
- **Key design decisions:**
  - DEFAULT_PLACE_RADIUS_M = 150m (matches PostGIS ST_DWithin behavior)
  - PLACE_MATCH_THRESHOLD = 0.7 (70% of samples must match for place assignment)
  - Haversine distance for coordinate matching (Earth-accurate, ~1m precision)
  - Source ID format: `location:{windowStartMs}:{placeId}:{segmentStartMs}` for deterministic reconciliation
  - Segment boundaries clamped to window boundaries
  - Confidence = sample count contribution (0.3-0.6) + place match bonus (0-0.4)
- **Learnings for future iterations:**
  - Reuse haversine distance function from evidence-data.ts rather than reimplementing (kept for now for locality)
  - Location segment generation is separate from commute detection (US-009) for clarity
  - mergeAdjacentSegments handles GPS drift scenarios
  - segmentsToDerivedEvents creates proper meta structure for reconciliation pipeline

---

## 2026-01-29 - US-007
- **What was implemented:** fetchLocationEvidenceForWindow function for ingestion pipeline
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/evidence-data.ts` (modified)
- **Functions created:**
  - `fetchLocationEvidenceForWindow(userId, windowStart, windowEnd)` - Main function that combines all location data sources
  - `fetchLocationSamplesForWindow(userId, windowStart, windowEnd)` - Query raw GPS points in time window
  - `fetchLocationHourlyForWindow(userId, windowStart, windowEnd)` - Query aggregated hourly data with place joins
  - `haversineDistance(lat1, lon1, lat2, lon2)` - Calculate distance between two coordinates in meters
  - `findMatchingPlace(latitude, longitude, userPlaces)` - Find best matching user place using haversine (ST_DWithin equivalent)
  - `calculateConfidence(sampleCount, avgAccuracyM)` - Calculate confidence score 0-1 based on data quality
  - `buildLocationEvidence(samples, hourlyData, userPlaces, windowStart, windowEnd)` - Combine data into LocationEvidence array
  - `createEvidenceFromSegment(segment, windowStart, windowEnd)` - Create single LocationEvidence from sample segment
- **Types created:**
  - `LocationEvidence` - Exported interface with start, end, place_id, place_label, latitude, longitude, confidence
  - `WindowLocationSample` - Internal type for raw location samples
- **Key design decisions:**
  - Raw samples preferred over hourly aggregates for precise timestamps
  - Groups consecutive samples by matching place to create segments
  - Falls back to hourly aggregates when no raw samples available
  - Haversine distance used client-side to replicate ST_DWithin database behavior
  - Confidence calculation: 0.3-0.7 base from sample count (up to 10 samples), +0.3 accuracy bonus (<20m excellent, <50m good, <100m okay)
  - Segment boundaries clamped to window boundaries
- **Learnings for future iterations:**
  - Reuse existing `fetchUserPlaces` function rather than reimplementing
  - Hour boundaries for hourly query expanded to capture overlapping hours (floor start, ceil end)
  - LocationEvidence segments match consecutive samples with same place_id (including null for unknown)
  - Pre-existing typecheck error at line 438 (healthDaily: [] should be null) is unrelated to this change

---

## 2026-01-29 - US-006
- **What was implemented:** Trailing edge extension for screen-time sessions
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.ts` (modified)
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.test.ts` (modified)
- **Functions created:**
  - `findExtendableEvent(existingEvents, windowStart, appId)` - Finds the most recent event ending near window start with matching app_id
  - `computeReconciliationOpsWithExtension(existingEvents, derivedEvents, previousWindowEvents)` - Reconciliation with extension support
  - `canExtendEvent(derived, existing)` - Check if derived event can extend an existing event
  - `fetchExtensionCandidates(userId, windowStart)` - Database query for extension candidates
  - `extendEvent(eventId, newEnd)` - Update event's scheduled_end
  - `executeExtensions(extensions)` - Execute all extension operations from ReconciliationOps
- **Key design decisions:**
  - Extension gap threshold: 60 seconds (events ending within 60s of window start can be extended)
  - Only the most recent event is extended (not multiple)
  - Different app_id creates separate events
  - Locked events cannot be extended (protected)
  - Extension creates "extend" operation type in ReconciliationOps
- **Tests added:** 17 new tests (29 total in file)
  - findExtendableEvent: 6 tests for gap/app matching
  - canExtendEvent: 5 tests for gap threshold and app matching
  - computeReconciliationOpsWithExtension: 6 tests for continuous sessions, gaps, and locked events
- **Learnings for future iterations:**
  - Extension logic is separate from core reconciliation for clarity
  - Use EXTENSION_GAP_THRESHOLD_MS constant (60s) for configurable threshold
  - ExtendableEvent type added but not yet used (for future database operations)
  - Extension candidates fetched from previous window, not current window

---

## 2026-01-29 - US-005
- **What was implemented:** Event reconciliation service with locked event protection
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.ts` (new)
  - `apps/mobile/src/lib/supabase/services/event-reconciliation.test.ts` (new)
- **Functions created:**
  - `computeReconciliationOps(existingEvents, derivedEvents)` - Computes inserts/updates/deletes while protecting locked events
  - `fetchEventsInWindow(userId, windowStart, windowEnd)` - Fetch events with locked_at status
  - `lockEventsInWindow(userId, windowStart, windowEnd)` - Set locked_at on all events in window
  - `hasLockedEventsInWindow(userId, windowStart, windowEnd)` - Check if any events are locked
  - `getLockedEventsInRange(userId, startTime, endTime)` - Get all locked events in range
- **Key design decisions:**
  - Locked events (locked_at IS NOT NULL) cannot be deleted or modified
  - User-edited events (source = 'user' or 'actual_adjust') protected from deletion even if unlocked
  - Derived events matched by source_id, can be updated if times change
  - New inserts skipped if they would overlap with protected events
- **Learnings for future iterations:**
  - Handle missing locked_at column gracefully (for pre-migration compatibility)
  - Use lockedAt: null vs undefined to distinguish "not locked" from "column doesn't exist"
  - Tests cover all 6 acceptance criteria scenarios
  - Pre-existing typecheck errors in codebase don't affect new service files
  - Types: ReconciliationEvent, DerivedEvent, ReconciliationOp, ReconciliationOps

---

## 2026-01-29 - US-004
- **What was implemented:** Window lock service for actual ingestion pipeline
- **Files changed:**
  - `apps/mobile/src/lib/supabase/services/actual-ingestion-window-locks.ts` (new)
- **Functions created:**
  - `isWindowLocked(userId, windowStart)` - Check if window is already processed
  - `lockWindow({ userId, windowStart, windowEnd, stats })` - Mark window as processed with stats
  - `processIngestionWindow({ userId, windowStart, windowEnd, process })` - Wrapper that checks lock, runs callback, then locks
  - `getWindowLock(userId, windowStart)` - Get lock record details
  - `getLockedWindowsInRange(userId, startTime, endTime)` - Get all locked windows in range
  - `checkWindowLockBeforeProcessing(userId, windowStart)` - Returns { skipped: true } if locked
- **Learnings for future iterations:**
  - Follow data-sync-state.ts pattern for service structure
  - Use `maybeSingle()` for queries that may return 0 or 1 rows
  - Handle missing table errors gracefully (for new tables not yet migrated)
  - Use `__DEV__` guard for development-only console warnings
  - Upsert with `onConflict` uses column names without prefix (e.g., `"user_id,window_start"`)
  - Types: WindowLock, WindowLockStats, WindowLockInsert, ProcessIngestionWindowResult

---

## 2026-01-29 - US-003
- **What was implemented:** Added CHECK constraint for category values to existing tm.user_app_categories table
- **Files changed:**
  - `supabase/migrations/20260129_user_app_categories_check_constraint.sql` (new)
- **Learnings for future iterations:**
  - The tm.user_app_categories table already existed (created in 20260119_user_app_categories_learning.sql)
  - When a table already exists, add only what's missing (e.g., constraints, indexes)
  - CHECK constraints for allowed category values: work, social, entertainment, comms, utility, ignore
  - Use DO blocks with pg_constraint checks for idempotent constraint creation
  - Column `app_key` in existing table serves same purpose as PRD's `app_id` - no need to rename

---

## 2026-01-29 - US-002
- **What was implemented:** Added locked_at column to tm.events table
- **Files changed:**
  - `supabase/migrations/20260129_add_locked_at_to_tm_events.sql` (new)
- **Learnings for future iterations:**
  - ALTER TABLE with ADD COLUMN IF NOT EXISTS is idempotent
  - Partial indexes use WHERE clause to only index non-null rows - more efficient for sparse columns
  - Column comments are useful for documentation in database schema
  - Existing typecheck errors in mobile app don't affect SQL migrations

---

## 2026-01-29 - US-001
- **What was implemented:** Created tm.actual_ingestion_window_locks table migration
- **Files changed:**
  - `supabase/migrations/20260129_create_tm_actual_ingestion_window_locks.sql` (new)
- **Learnings for future iterations:**
  - Migration follows established pattern with idempotent DDL
  - Table uses same FK pattern to auth.users(id) as other tm tables
  - UNIQUE constraint on (user_id, window_start) ensures idempotent lock operations
  - Index on (user_id, window_start) for fast lock lookups
  - RLS policies for select/insert allow users to manage their own locks
  - Pre-existing typecheck errors in mobile app are unrelated to migrations

---

