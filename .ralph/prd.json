{
  "name": "Today Matters â€“ Incremental Actual Ingestion (Android-first)",
  "version": "0.1.0",
  "owner": "Cole",
  "status": "in_progress",
  "branchName": "feat/incremental-actual-ingestion",
  "problem": {
    "summary": "The current Actual timeline is unstable: it rebuilds a full-day display pipeline frequently, auto-saves derived/evidence blocks, and can produce unknown blocks despite evidence, sleep not shifting, and overlapping/duplicated events.",
    "root_causes": [
      "Full-day recomputation + multiple auto-sync paths cause churn/duplicates.",
      "Overlap prevention blocks insertion of evidence blocks.",
      "Evidence thresholds (e.g., 10 min) + missing labels lead to Unknown.",
      "Existing tm.screen_time_app_sessions data is not yet used for incremental ingestion reconciliation."
    ]
  },
  "goal": {
    "primary": "Create a stable, incremental ingestion pipeline that materializes Actual events as a deterministic ledger, processing the prior 30-minute window every 30 minutes and reconciling into Supabase without rewriting the whole day.",
    "success_metrics": [
      "Idempotency: re-running the same window produces 0 net changes.",
      "Stability: events older than a configurable cutoff are not mutated automatically.",
      "Coverage: Unknown blocks in a processed window are replaced/split when evidence exists.",
      "No overlaps in persisted Actuals (1-minute granularity or better)."
    ]
  },
  "non_goals": [
    "iOS Screen Time ingestion (can be added later).",
    "Health-based derivation (explicitly ignored for now).",
    "Full pattern-based suggestions."
  ],
  "userStories": [
    {
      "id": "US-001",
      "title": "Create actual_ingestion_checkpoints migration",
      "description": "Create the tm.actual_ingestion_checkpoints table to store per-user watermarks for tracking which time windows have been processed.",
      "acceptance_criteria": [
        "Migration creates tm.actual_ingestion_checkpoints table with fields: user_id, timezone, last_processed_at, last_processed_window_start, last_processed_window_end, updated_at",
        "Table has RLS enabled with policies for select/insert/update own rows",
        "Table has proper indexes for efficient queries",
        "Migration is idempotent (can be run multiple times safely)"
      ],
      "priority": 1,
      "passes": false
    },
    {
      "id": "US-002",
      "title": "Implement ingestion service core logic",
      "description": "Create the ActualIngestionService that fetches evidence from screen_time_app_sessions and reconciles it into calendar_actual events.",
      "acceptance_criteria": [
        "Service can query screen_time_app_sessions for a given time window",
        "Service can build candidate segments from usage sessions",
        "Service computes deterministic source_id for idempotency",
        "Service handles window alignment to 30-minute boundaries",
        "TypeScript types are properly defined"
      ],
      "priority": 2,
      "passes": false
    },
    {
      "id": "US-003",
      "title": "Implement reconciliation algorithm",
      "description": "Implement the split/merge logic that reconciles evidence segments into existing Actual events without creating overlaps.",
      "acceptance_criteria": [
        "Algorithm fetches existing calendar_actual events that overlap the window",
        "User-edited events (source='user' or 'actual_adjust') are never overwritten",
        "Evidence segments replace Unknown and derived segments",
        "No overlapping events after reconciliation",
        "Adjacent events with same attributes can be merged"
      ],
      "priority": 3,
      "passes": false
    },
    {
      "id": "US-004",
      "title": "Implement gap filling for processed windows",
      "description": "After reconciliation, fill any uncovered minutes in the window with Unknown blocks.",
      "acceptance_criteria": [
        "Gaps in the processed window are filled with Unknown blocks",
        "Unknown blocks have proper meta.source and meta.kind",
        "Gap filling only applies to the current window, not the entire day"
      ],
      "priority": 4,
      "passes": false
    },
    {
      "id": "US-005",
      "title": "Add useActualIngestion hook",
      "description": "Create a React hook that triggers the ingestion service on app foreground/resume, similar to useInsightsSync.",
      "acceptance_criteria": [
        "Hook triggers ingestion on app foreground/resume",
        "Hook respects the 30-minute interval (doesn't run more frequently)",
        "Hook updates the checkpoint after successful processing",
        "Hook handles errors gracefully without crashing the app"
      ],
      "priority": 5,
      "passes": false
    },
    {
      "id": "US-006",
      "title": "Add Supabase types for new table",
      "description": "Regenerate or manually add TypeScript types for the actual_ingestion_checkpoints table.",
      "acceptance_criteria": [
        "TypeScript types exist for actual_ingestion_checkpoints table",
        "Types are properly exported and usable in the service"
      ],
      "priority": 6,
      "passes": false
    }
  ],
  "scope": {
    "platforms": ["android"],
    "data_sources": [
      "tm.screen_time_app_sessions (ALREADY EXISTS - sessionized Android usage)",
      "tm.location_samples + tm.location_hourly (ALREADY EXISTS)",
      "tm.user_places (ALREADY EXISTS - labeled locations)"
    ],
    "write_targets": [
      "tm.events (type=calendar_actual)",
      "tm.actual_ingestion_checkpoints (NEW - watermarks)"
    ]
  },
  "principles": [
    "Ledger-first: Persisted Actuals are the source of truth; UI should not constantly rewrite them.",
    "Incremental: Only reconcile a small time window per run (+ small buffer).",
    "Respect user edits: Never overwrite user/actual_adjust blocks automatically.",
    "Split > relabel: When a short evidence segment exists inside a larger block, split and replace only the segment.",
    "Deterministic + idempotent: Stable keys, stable merge rules, safe re-runs."
  ],
  "algorithm": {
    "cadence": {
      "interval_minutes": 30,
      "window": "[now-30m, now)",
      "buffer_minutes": 10,
      "mutable_cutoff_minutes": 120
    }
  }
}
