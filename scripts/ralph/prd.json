{
  "project": "TodayMatters V2",
  "branchName": "ralph/v2-bugs-and-features",
  "description": "Critical bug fixes (Android location, edit persistence, pipeline loops), timeline accuracy improvements, hierarchical categories, Big 3 daily priorities, location intelligence, setup enhancements, split event redesign, and groundwork for location-based reminders and contextual lists.",
  "userStories": [
    {
      "id": "US-026",
      "title": "Investigate Android Location canStart Failure",
      "description": "As a developer, I need to debug why Android location diagnostics show canStart: false despite all permissions granted, background task registered, and services enabled. Pending samples is 0 — location data is not being collected at all.",
      "acceptanceCriteria": [
        "Read android-location/index.ts and trace the canStart logic to identify which condition returns false",
        "Read android-location/location-task.ts and verify the background task registration and callback",
        "Read android-location/queue.ts and verify sample queuing logic",
        "Add verbose diagnostic logging to canStart check showing each condition's value",
        "Add logging to location task callback to confirm it fires (or doesn't fire) on Android",
        "Add last successful sample timestamp and 24h sample count to getAndroidLocationDiagnostics()",
        "Document findings in progress.txt for root cause analysis",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "COMPLETED — Found root cause: canStart logic was self-contradictory. When taskStarted=false and all checks pass, it pushed a spurious error making canStart always false. Fixed in index.ts. Added verbose logging to location-task.ts and diagnostics to profile.tsx."
    },
    {
      "id": "US-027",
      "title": "Fix Android Location Background Collection",
      "description": "As an Android user, I need location data to actually collect in the background so the app can infer where I was. Based on US-026 investigation, implement the fix.",
      "acceptanceCriteria": [
        "Based on US-026 findings, fix the root cause preventing location collection",
        "Verify expo-location background task registers and fires on Android",
        "Location samples are written to tm.location_samples when collected",
        "Location samples sync to tm.location_hourly via existing sync logic",
        "SparseLocationFallback only activates when location data is genuinely sparse (not always)",
        "Add a fallback/retry mechanism if background task fails to start",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "COMPLETED — US-026 fixed the canStart logic bug (root cause). US-027 added: typed result from startAndroidBackgroundLocationAsync with production logging on every failure path, try/catch around native startLocationUpdatesAsync, isAndroidBackgroundLocationRunningAsync health check helper, periodic 5-min health check in sync hook with auto-restart, foreground-resume restart, retry backoff (max 3 attempts). Location samples flow: background task → AsyncStorage queue → flush every 2min → Supabase tm.location_samples → SQL view tm.location_hourly (auto-aggregated). SparseLocationFallback is not an actual code construct — it's a conceptual PRD term. The actual fallback behavior is handled correctly by the evidence pipeline which checks for presence of location data."
    },
    {
      "id": "US-028",
      "title": "Fix Screen Time Session Duration (0 min bug)",
      "description": "As a developer, I need to fix screen time showing '5 sessions, 0 min' — sessions are detected but durations are zero. This may be an Android Usage Stats API parsing issue.",
      "acceptanceCriteria": [
        "Investigate AndroidInsightsModule.kt — verify usage stats query returns non-zero foreground times",
        "Check if getUsageSummarySafeAsync() correctly parses session durations from native module",
        "Verify screen-time-sync.ts correctly maps Android session durations to Supabase",
        "Fix the 0 min duration — sessions should show actual foreground time",
        "Add logging showing raw native duration vs parsed TypeScript duration for debugging",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "COMPLETED — Two root causes found and fixed: (1) Kotlin: queryUsageStats aggregate returns totalTimeInForeground=0 on many Android OEMs because stats aren't aggregated until end-of-day; added fallback to sum session durations from queryEvents which works in real-time, plus rebuild topApps from sessions. (2) TypeScript: syncAndroidUsageSummary was passing [] to replaceAppSessions and not writing screen_time_app_hourly at all; now persists both Android sessions and hourlyByApp data to Supabase. Added production logging in both Kotlin (Log.d) and TypeScript (console.log) for debugging."
    },
    {
      "id": "US-029",
      "title": "Fix Event Edit Persistence — Diagnose and Fix Save Failures",
      "description": "As a user, I want my edits to event titles, categories, and times to persist reliably. Currently some edits revert after saving.",
      "acceptanceCriteria": [
        "Trace the save flow in actual-adjust.tsx from UI save handler to Supabase write",
        "Verify updateActual() in calendar-events.ts is called and returns success",
        "Verify the events store is updated AFTER successful Supabase write (not before/optimistically)",
        "Verify syncDerivedActualEvents does not overwrite user edits with re-derived data",
        "Add source: 'actual_adjust' to meta when saving edits so re-derivation skips these events",
        "After edit + save, navigate away and back — edit must persist",
        "Show user-visible error toast/alert if save fails (not silent rollback)",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "COMPLETED — Three fixes: (1) Added user-visible Alert on save failure in actual-adjust.tsx (was silently swallowing errors). (2) Added 'actual_adjust' to CalendarEventMeta source type union and used `as const` to fix TS type widening. (3) syncDerivedActualEvents now skips derived events that overlap user-edited events (source: 'actual_adjust' or 'user'), preventing re-derivation from overwriting user edits. Verified: store updates happen AFTER successful Supabase write, updateActual() returns mapped ScheduledEvent, source: 'actual_adjust' was already set in meta."
    },
    {
      "id": "US-030",
      "title": "Make Unknown Events Editable",
      "description": "As a user, I want to tap and edit 'Unknown' events just like any other event. Currently some Unknown events block editing entirely.",
      "acceptanceCriteria": [
        "Identify why some unknown_gap events don't open the edit screen (check navigation/tap handler)",
        "Ensure all events with meta.kind === 'unknown_gap' are tappable in ComprehensiveCalendarTemplate",
        "Unknown events open actual-adjust screen with full editing: title, start/end time, category",
        "Edited unknown events are persisted with source: 'user_input' or source: 'actual_adjust'",
        "After editing, the event no longer shows as 'Unknown' in the timeline",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": "COMPLETED — Two root causes found: (1) CalendarEvent local type lacked meta field, preventing kind-based detection of unknown_gap events. (2) Productive unknown events (kind: 'unknown_gap', category: 'work') were blocked by handleOpenEditor which only checked category === 'unknown'. Fixes: Added meta to CalendarEvent type, expanded isUnknown check to include meta.kind === 'unknown_gap', added direct actual-adjust routing for all unknown_gap kind events in TimeEventBlock.handlePress(), and updated handleOpenEditor to allow unknown_gap kind events through. Persistence uses existing source: 'actual_adjust' flow. After editing, the derived Unknown event is suppressed by overlap check in buildActualDisplayEvents."
    },
    {
      "id": "US-031",
      "title": "Fix Evidence Pipeline Re-Processing Loop",
      "description": "As a developer, I need the evidence pipeline to run once per data change, not 8+ times per cycle. Logs show SparseLocationFallback, EvidenceAvailability, and EvidenceFusion repeating excessively.",
      "acceptanceCriteria": [
        "Identify what triggers pipeline re-runs in comprehensive-calendar.tsx (React re-renders, polling, state changes)",
        "Add input hashing or memoization to buildActualDisplayEvents so it skips if inputs haven't changed",
        "Cache pipeline result and reuse until inputs change (events, evidence data, or user edits)",
        "Evidence pipeline runs at most 1-2 times per user action or data sync event",
        "SparseLocationFallback/EvidenceAvailability/EvidenceFusion log lines appear 1-2 times per cycle (not 8+)",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": true,
      "notes": "COMPLETED — Three root causes fixed: (1) useMemo dependency array in comprehensive-calendar.tsx included entire userPreferences object instead of individual primitive fields, causing recalculation on any unrelated preference store mutation. (2) useVerification hook ran verifyPlannedEvents+generateActualBlocks twice: once in refresh() and again in re-verification effect when evidence changed. Fixed by adding fingerprint tracking (lastVerificationInputs ref) so re-verification effect skips when inputs match what refresh() already computed. (3) refresh callback had appCategoryOverrides, plannedEvents, verificationStrictness in deps, causing identity changes that cascaded to auto-fetch effect. Fixed by using stable refs for these values inside the callback, reducing deps to [isAuthenticated, userId, ymd]. Added module-level fingerprint cache to buildActualDisplayEvents as last-line defense — returns cached result when inputs are identical."
    },
    {
      "id": "US-032",
      "title": "Fix Event Time Accuracy — Audit and Fix Rounding",
      "description": "As a user, I want event times to match reality. Currently times are systematically wrong (e.g., left at 9:30, app shows 9:00) due to rounding or bucketing.",
      "acceptanceCriteria": [
        "Audit time assignment in actual-display-events.ts — identify where rounding/bucketing to hour boundaries occurs",
        "Audit evidence-fusion.ts — check if evidence timestamps are being rounded",
        "When location data shows arrival at 9:32, the event should start at 9:32 (nearest minute), not 9:00",
        "Calendar-sourced events use actual calendar start time without bucketing",
        "Add debug logging: raw evidence timestamp vs assigned startMinutes for each event",
        "Fix any hourly bucketing that converts precise timestamps to hour boundaries",
        "Typecheck passes"
      ],
      "priority": 7,
      "passes": true,
      "notes": "COMPLETED — Two root causes fixed: (1) buildLocationBlocks used hour_start from location_hourly view (snapped to hour boundaries by SQL date_trunc) and assumed 60-min blocks, making all location events start at :00. Fixed by fetching raw location_samples with precise recorded_at timestamps and using them to compute actual first/last sample minute within each hourly row. (2) Session time conversion used getHours()*60+getMinutes() which truncated seconds (9:32:45 → 572 instead of 573). Added dateToMinutes() helper using Math.round with seconds precision, replaced all 6 occurrences. evidence-fusion.ts was clean — no timestamp rounding. Calendar-sourced events already used planned.startMinutes directly (no bucketing). Added debug logging in buildLocationBlocks."
    },
    {
      "id": "US-033",
      "title": "Fix Event Inference — Don't Label as Screen Time Without Evidence",
      "description": "As a user, I don't want events labeled as 'screen time' when I wasn't actually using my phone. The app should only use screen time as the primary label when screen usage is the dominant activity.",
      "acceptanceCriteria": [
        "When no screen time evidence exists for a time block, never label it as screen time",
        "Screen time is only the primary label when screen usage accounts for >50% of the block's duration",
        "Blocks without screen time or location evidence default to 'Unknown' (not screen time)",
        "Leverage user's tm.location_mappings for known places before falling back to generic labels",
        "Add 'Travel' as a recognized activity kind in evidence-fusion when location changes between stationary points",
        "Typecheck passes"
      ],
      "priority": 8,
      "passes": true,
      "notes": "COMPLETED — Five fixes: (1) replaceUnknownWithProductiveUsage now requires screen time >50% of block duration before labeling as productive. (2) buildLocationEvent checks user-defined places (tm.user_places) via resolveFromUserPlaces() before falling back to generic mapPlaceToCategory inference. (3) Added 'travel' kind to CalendarEventMeta and updated commute/transition detection to use category:'travel' + kind:'travel' with descriptive titles like 'Travel: Home → Church'. (4) Lowered travel detection minimum from 15 to 5 minutes (matching AC: <5 min within same area NOT flagged as travel). (5) Blocks without screen/location evidence remain 'Unknown' — fillUnknownGaps was already correct, the issue was aggressive productive labeling in (1)."
    },
    {
      "id": "US-034",
      "title": "Create Hierarchical Activity Categories Schema",
      "description": "As a developer, I need a database schema for hierarchical categories (Category → Subcategory → Sub-subcategory) to replace the flat EventCategory enum.",
      "acceptanceCriteria": [
        "Create Supabase migration for tm.activity_categories table: id, user_id, parent_id (null = top-level), name, icon, color, sort_order, created_at, updated_at",
        "Unique constraint on (user_id, parent_id, name) to prevent duplicate categories at same level",
        "parent_id is a self-referencing foreign key to tm.activity_categories.id",
        "Row Level Security: users can only access own categories",
        "Seed top-level categories: Faith, Family, Work, Health, Personal Growth, Finances, Other",
        "Other is a permanent top-level category (add constraint or note for app logic)",
        "Create TypeScript types: ActivityCategory, ActivityCategoryInsert, ActivityCategoryUpdate",
        "Typecheck passes"
      ],
      "priority": 9,
      "passes": true,
      "notes": "COMPLETED — Created Supabase migration for tm.activity_categories table with self-referencing parent_id FK for hierarchical categories. Includes: unique constraint on (user_id, parent_id, name), RLS policies for select/insert/update/delete, updated_at trigger, sort_order for ordering. Added seed_default_activity_categories(p_user_id) SQL function that creates 7 default top-level categories (Faith, Family, Work, Health, Personal Growth, Finances, Other) idempotently. Added TypeScript types (ActivityCategory, ActivityCategoryInsert, ActivityCategoryUpdate) derived from Database['tm']['Tables']['activity_categories'] in database.types.ts. Exported from services/index.ts."
    },
    {
      "id": "US-035",
      "title": "Create Activity Categories CRUD Service",
      "description": "As a developer, I need Supabase CRUD functions for the hierarchical activity categories system.",
      "acceptanceCriteria": [
        "Create apps/mobile/src/lib/supabase/services/activity-categories.ts",
        "Functions: fetchActivityCategories (all for user), fetchTopLevelCategories, fetchSubcategories(parentId)",
        "Functions: createActivityCategory, updateActivityCategory, deleteActivityCategory",
        "fetchActivityCategories returns flat list; add buildCategoryTree() helper to nest them",
        "Deleting a parent cascades or blocks if children exist (choose block with error message)",
        "Export from services/index.ts",
        "Typecheck passes"
      ],
      "priority": 10,
      "passes": true,
      "notes": "COMPLETED — Created CRUD service in activity-categories.ts with: fetchActivityCategories (flat list, ordered by sort_order), fetchTopLevelCategories (parent_id is null), fetchSubcategories(parentId), createActivityCategory, updateActivityCategory, deleteActivityCategory (blocks if children exist with error message). Added buildCategoryTree() helper that converts flat list to nested ActivityCategoryNode[] tree. Added ActivityCategoryNode interface extending ActivityCategory with children array. Uses tmSchema() helper pattern for tm schema access. Already exported from services/index.ts (from US-034)."
    },
    {
      "id": "US-036",
      "title": "Create Hierarchical Category Picker Component",
      "description": "As a user, I want a category picker that shows my hierarchical categories with expand/collapse so I can select the right category when editing events.",
      "acceptanceCriteria": [
        "Create HierarchicalCategoryPicker molecule component",
        "Shows top-level categories; tap to expand and see subcategories",
        "Subcategories are indented and can also expand to show sub-subcategories",
        "Selecting any category at any level calls onSelect with the category id and full path",
        "Currently selected category is highlighted",
        "Search/filter input at top to filter categories by name",
        "Component accepts categories prop (from CRUD service) and selectedCategoryId",
        "Typecheck passes"
      ],
      "priority": 11,
      "passes": true,
      "notes": "COMPLETED — Created HierarchicalCategoryPicker molecule component at components/molecules/HierarchicalCategoryPicker.tsx. Features: (1) Accepts flat ActivityCategory[] and builds tree via buildCategoryTree(). (2) Top-level categories shown with expand/collapse chevrons; tap chevron to reveal subcategories indented by 20px per depth level. (3) Sub-subcategories also expandable (recursive rendering). (4) onSelect returns category id AND full CategoryPath (array of names from root to leaf). (5) Selected category highlighted with blue background + checkmark + bold blue text. (6) Search input at top filters by name — matching branches auto-expand, non-matching branches pruned. Matched text highlighted in bold blue. (7) Props: categories, selectedCategoryId, onSelect. (8) Exported from molecules/index.ts with CategoryPath and HierarchicalCategoryPickerProps types. Uses NativeWind styling, lucide-react-native icons (ChevronRight, ChevronDown, Search, Check), color dot for categories with color field. Zero new TS errors."
    },
    {
      "id": "US-037",
      "title": "Integrate Category Picker into Event Editor",
      "description": "As a user, I want to use the hierarchical category picker when editing events in actual-adjust.",
      "acceptanceCriteria": [
        "Replace flat category dropdown in actual-adjust.tsx with HierarchicalCategoryPicker",
        "Load user's categories from Supabase on mount",
        "Selected category is saved to event meta as category_id (new field) alongside existing category enum",
        "Add category_id to CalendarEventMeta type in events-store.ts",
        "Persist category_id to Supabase when saving event edits",
        "Typecheck passes"
      ],
      "priority": 12,
      "passes": true,
      "notes": "COMPLETED — Integrated HierarchicalCategoryPicker into event editor. Added category_id to CalendarEventMeta type. ActualAdjustTemplate conditionally renders hierarchical picker when activityCategories are loaded (falls back to flat LIFE_AREA_OPTIONS when no categories exist). actual-adjust.tsx fetches user categories via fetchActivityCategories on mount, tracks selectedCategoryId state, and includes category_id in meta on save. The existing EventCategory enum is preserved alongside category_id for backward compatibility."
    },
    {
      "id": "US-038",
      "title": "Update Setup Core Categories Screen for Hierarchical System",
      "description": "As a user, I want to add unlimited subcategories per category during setup using the new hierarchical system.",
      "acceptanceCriteria": [
        "Update core-categories.tsx to use tm.activity_categories instead of flat list",
        "Users can add unlimited subcategories under any top-level category",
        "Other always appears as a top-level category",
        "LLM suggestion engine generates subcategory ideas based on user's goals and values (existing behavior)",
        "Categories created during setup are saved to tm.activity_categories via CRUD service",
        "Typecheck passes"
      ],
      "priority": 13,
      "passes": true,
      "notes": "COMPLETED — Rewrote core-categories.tsx to use tm.activity_categories instead of flat CoreCategory[] in onboarding store. On mount: seeds default top-level categories via seedDefaultActivityCategories() (idempotent — creates Faith, Family, Work, Health, Personal Growth, Finances, Other), then fetches all categories. Top-level categories render as expandable sections. Users add unlimited subcategories via createActivityCategory() with parent_id. Subcategories are deleted via deleteActivityCategory(). 'Other' always appears as a permanent top-level category from the seed function. LLM suggestion engine (generateOnboardingCategorySuggestionsLlm) generates subcategory ideas by mapping top-level categories as 'values' and existing subcategories as 'categories'. Template updated to use ActivityCategory type from the CRUD service. All categories are persisted directly to tm.activity_categories — no intermediate onboarding store sync needed."
    },
    {
      "id": "US-039",
      "title": "Create Big 3 Daily Priorities Schema",
      "description": "As a developer, I need a database table to store daily Big 3 priorities and a user preference for opt-in.",
      "acceptanceCriteria": [
        "Create Supabase migration for tm.daily_big3 table: id, user_id, date, priority_1 (text), priority_2 (text), priority_3 (text), category_id_1, category_id_2, category_id_3, created_at, updated_at",
        "Unique constraint on (user_id, date) — one Big 3 set per day",
        "Row Level Security: users can only access own Big 3",
        "Create TypeScript types: DailyBig3, DailyBig3Insert, DailyBig3Update",
        "Create CRUD service: fetchBig3ForDate, upsertBig3ForDate, deleteBig3ForDate",
        "Add 'big3_enabled' preference key to user preferences (use existing tm.user_preferences)",
        "Export from services/index.ts",
        "Typecheck passes"
      ],
      "priority": 14,
      "passes": true,
      "notes": "COMPLETED — Created Supabase migration for tm.daily_big3 table with: id, user_id, date, priority_1/2/3 (text), category_id_1/2/3 (FK → activity_categories, ON DELETE SET NULL), created_at, updated_at. Unique constraint on (user_id, date). RLS policies for select/insert/update/delete. Updated-at trigger. Added big3_enabled boolean column to tm.user_data_preferences. Updated database.types.ts with daily_big3 Row/Insert/Update/Relationships types. Created daily-big3.ts CRUD service with fetchBig3ForDate (maybeSingle), upsertBig3ForDate (onConflict: user_id,date), deleteBig3ForDate. Added big3Enabled to UserDataPreferences interface, DEFAULT_USER_PREFERENCES (false), and user-preferences service (fetch/upsert read/write big3_enabled column). Exported from services/index.ts. Zero new TS errors."
    },
    {
      "id": "US-040",
      "title": "Add Big 3 Opt-In to Setup Flow",
      "description": "As a user, I want to be asked during setup whether I want to use the Big 3 concept. If I opt in, it becomes part of my daily workflow.",
      "acceptanceCriteria": [
        "Add new setup screen between existing screens asking 'Do you want to use the Big 3 concept?'",
        "Explain Big 3: 'Each day, pick 3 things that would make today a success'",
        "Two options: 'Yes, enable Big 3' and 'No thanks, skip'",
        "Save preference to tm.user_preferences via existing user preferences service",
        "Add screen to setup-screens.ts constant array in correct position",
        "Update onboarding store to track big3_enabled preference",
        "Typecheck passes"
      ],
      "priority": 15,
      "passes": true,
      "notes": "COMPLETED — Created Big3OptInTemplate and big3-opt-in.tsx setup screen. Screen inserted between setup-questions and ai-summary (step 13 of 14). Two options: 'Yes, enable Big 3' (saves big3Enabled: true) and 'No thanks, skip' (saves big3Enabled: false). Preference saved to tm.user_data_preferences via upsertUserDataPreferences and to user-preferences Zustand store. Onboarding store updated with big3Enabled field and setBig3Enabled action. Navigation: setup-questions → big3-opt-in → ai-summary. ai-summary back button goes to big3-opt-in."
    },
    {
      "id": "US-041",
      "title": "Add Big 3 Assignment to Event Editor",
      "description": "As a user, I want to assign a time block to one of my Big 3 priorities when editing an event.",
      "acceptanceCriteria": [
        "In actual-adjust.tsx, add 'Mark as Big 3' section (only visible if big3_enabled preference is true)",
        "Load today's Big 3 priorities from Supabase",
        "Show 3 tappable buttons with each priority text — tap to assign this event",
        "Assigned Big 3 priority stored in event meta as big3_priority (1, 2, or 3) and isBig3: true",
        "Tap again to unassign (toggle behavior)",
        "If no Big 3 set for today, show 'Set your Big 3 for today' prompt with inline input",
        "Typecheck passes"
      ],
      "priority": 16,
      "passes": true,
      "notes": "COMPLETED — Replaced simple Big 3 toggle with full priority assignment section in event editor. Big3Section component conditionally renders when big3Enabled preference is true. When Big 3 priorities exist for today (loaded from tm.daily_big3 via fetchBig3ForDate), shows 3 tappable priority buttons with toggle behavior (tap to assign, tap again to unassign). Assigned priority stored as big3_priority (1, 2, or 3) and isBig3: true in CalendarEventMeta. When no Big 3 set for today, shows inline input form with 3 text fields and 'Save Big 3' button that persists via upsertBig3ForDate. Added big3_priority field to CalendarEventMeta type. Zero new TS errors (36 pre-existing)."
    },
    {
      "id": "US-042",
      "title": "Add Big 3 Progress to Home Screen",
      "description": "As a user, I want to see my Big 3 progress on the home screen — which priorities have time allocated and how much.",
      "acceptanceCriteria": [
        "On home.tsx, add Big 3 progress card (only visible if big3_enabled preference is true)",
        "Load today's Big 3 from Supabase and today's actual events",
        "For each priority, show: title, total minutes allocated, checkmark if any time assigned",
        "Show 0/3, 1/3, 2/3, 3/3 completion indicator",
        "If no Big 3 set for today, show 'Set your Big 3' call-to-action",
        "Typecheck passes"
      ],
      "priority": 17,
      "passes": true,
      "notes": "COMPLETED — Created Big3ProgressCard organism component on the home screen. Card only visible when big3Enabled preference is true (from useUserPreferencesStore). Loads today's Big 3 from Supabase via fetchBig3ForDate on mount. For each priority: shows title text, total minutes allocated (computed from actualEventsByDate events with meta.big3_priority), and a green checkmark circle if any time is assigned. Shows N/3 completion indicator in header. When no Big 3 set for today, shows 'Set your Big 3' CTA with inline input form (3 text fields + save). Persists via upsertBig3ForDate (fire-and-forget). Zero new TS errors (36 pre-existing)."
    },
    {
      "id": "US-043",
      "title": "Place Labeling — Add 'Label This Place' to Event Editor",
      "description": "As a user, I want to label a location from the event editor so future visits auto-tag correctly.",
      "acceptanceCriteria": [
        "In actual-adjust.tsx, when event has location evidence (locationLabel in meta), show 'Label this place' button",
        "Tapping opens inline form: place name (pre-filled with locationLabel), category picker (hierarchical)",
        "Save creates/updates tm.location_mappings with lat/lng (from evidence), label, category_id",
        "If place already has a label in location_mappings, show 'Edit place label' instead",
        "Use existing location-mappings.ts CRUD service (upsertLocationMapping)",
        "Add category_id column to tm.location_mappings if not present (migration)",
        "Typecheck passes"
      ],
      "priority": 18,
      "passes": true,
      "notes": "COMPLETED — The PRD referenced tm.location_mappings but the actual table is tm.user_places (created in US-018 migration). Added category_id column via migration. Updated user-places.ts service with fetchUserPlaceByLabel() and category_id support in upsertUserPlaceFromSamples(). Added PlaceLabelSection to ActualAdjustTemplate: shows 'Label this place' or 'Edit place label' button when event has locationLabel in meta, expands to inline form with place name input (pre-filled) and HierarchicalCategoryPicker. actual-adjust.tsx: checks existing place label on mount via fetchUserPlaceByLabel, fetches location samples for the event time range, upserts via upsertUserPlaceFromSamples with category_id. Updated UserPlaceRow in evidence-data.ts to include category_id."
    },
    {
      "id": "US-044",
      "title": "Place Auto-Tagging — Use Labels in Evidence Pipeline",
      "description": "As a user, I want labeled places to auto-populate event title and category on future visits.",
      "acceptanceCriteria": [
        "In actual-display-events.ts, when building events from location evidence, check tm.location_mappings",
        "If location matches a labeled place (within radius), auto-fill: title from label, category from category_id",
        "Auto-tagged events show 'Auto-tagged from [Place Name]' in evidence metadata",
        "Confidence boosted for auto-tagged events (location match with user label = high confidence)",
        "Location matching uses haversine distance with configurable radius (default 200m)",
        "User labels take priority over generic mapPlaceToCategory inference",
        "Typecheck passes"
      ],
      "priority": 19,
      "passes": false,
      "notes": "Depends on US-043 for label data. Uses existing location_mappings loaded in comprehensive-calendar.tsx (US-022)."
    },
    {
      "id": "US-045",
      "title": "Place Labels Management in Settings",
      "description": "As a user, I want to view, edit, and delete my place labels from Settings.",
      "acceptanceCriteria": [
        "Update existing LocationMappingsTemplate to show category alongside place label",
        "Show hierarchical category name (e.g., 'Family > Dog Walking') from activity_categories",
        "Edit modal includes category picker (HierarchicalCategoryPicker from US-036)",
        "Add count of auto-tagged events per place (query from events with matching location)",
        "Typecheck passes"
      ],
      "priority": 20,
      "passes": false,
      "notes": "Enhances existing location-mappings settings screen from US-020"
    },
    {
      "id": "US-046",
      "title": "Travel Segment Detection in Evidence Pipeline",
      "description": "As a user, I want the app to detect travel between locations and create Travel events automatically.",
      "acceptanceCriteria": [
        "In actual-display-events.ts, detect travel: when location changes between two stationary points, insert Travel event",
        "Travel duration = time between leaving location A and arriving at location B",
        "Travel events show origin and destination (e.g., 'Travel: Home → Church')",
        "Travel categorized with kind: 'travel' and category: 'travel'",
        "Short movements (<5 min) within same general area are NOT flagged as travel",
        "Travel events are editable like any other event",
        "Add 'travel' to EventCategory type if not present",
        "Typecheck passes"
      ],
      "priority": 21,
      "passes": false,
      "notes": "Requires location data to be working (US-027). Uses stationary point detection from location_hourly."
    },
    {
      "id": "US-047",
      "title": "Multi-Segment Event Split — Time Bar with Split Points",
      "description": "As a user, I want to split an event into 2-10 segments using a multi-point interface instead of a single slider.",
      "acceptanceCriteria": [
        "Replace slider in ActualSplitTemplate with a time bar showing the event's time range",
        "User taps on time bar to add split points (markers)",
        "Can add up to 9 split points (creating 10 segments max)",
        "Split points can be dragged to adjust position",
        "Split points can be removed by tapping an X button on each marker",
        "Preview below shows resulting segment count and each segment's time range/duration",
        "Minimum segment duration: 5 minutes (prevent tiny segments)",
        "Typecheck passes"
      ],
      "priority": 22,
      "passes": false,
      "notes": "Replaces current actual-split.tsx slider. Template is ActualSplitTemplate.tsx."
    },
    {
      "id": "US-048",
      "title": "Inline Sub-Event Editing After Split",
      "description": "As a user, I want to edit each sub-event's title, category, and Big 3 on the split screen without navigating away.",
      "acceptanceCriteria": [
        "After setting split points, show compact sub-event cards below the time bar",
        "Each card shows: time range, editable title input, category picker dropdown",
        "Tap a card to expand for full editing (description, subcategory, Big 3 toggle)",
        "Collapse card to return to compact view",
        "Save All button commits all sub-events via createActual() for each segment",
        "If any save fails, show error and keep all sub-events in edit state",
        "Original parent event is deleted after all sub-events save successfully",
        "Typecheck passes"
      ],
      "priority": 23,
      "passes": false,
      "notes": "Depends on US-047 multi-point split"
    },
    {
      "id": "US-049",
      "title": "Location-Based Reminders — Schema and Service",
      "description": "As a developer, I need the data model for location-based reminders (groundwork only — no UI or trigger logic).",
      "acceptanceCriteria": [
        "Create Supabase migration for tm.location_reminders: id, user_id, title, description, target_lat, target_lng, target_radius_meters, trigger_type ('on_arrival' | 'on_route' | 'nearby'), linked_event_id (nullable FK), items (JSONB array), active (boolean default true), created_at, updated_at",
        "Row Level Security: users can only access own reminders",
        "Create TypeScript types: LocationReminder, LocationReminderInsert, LocationReminderUpdate",
        "Create CRUD service: fetchLocationReminders, createLocationReminder, updateLocationReminder, deleteLocationReminder, fetchActiveReminders",
        "Export from services/index.ts",
        "No UI or trigger logic in this story",
        "Typecheck passes"
      ],
      "priority": 24,
      "passes": false,
      "notes": "Groundwork only — full implementation deferred to future PRD"
    },
    {
      "id": "US-050",
      "title": "Event-Based Contextual Lists — Schema and Service",
      "description": "As a developer, I need the data model for contextual checklists triggered by upcoming events (groundwork only — no UI or trigger logic).",
      "acceptanceCriteria": [
        "Create Supabase migration for tm.contextual_lists: id, user_id, name, trigger_type ('event_type' | 'calendar_keyword' | 'manual'), trigger_value (text), items (JSONB array of {text, checked}), advance_hours (integer, how far ahead to prompt), created_at, updated_at",
        "Row Level Security: users can only access own lists",
        "Create TypeScript types: ContextualList, ContextualListInsert, ContextualListUpdate, ContextualListItem",
        "Create CRUD service: fetchContextualLists, createContextualList, updateContextualList, deleteContextualList, fetchListsByTrigger",
        "Export from services/index.ts",
        "No notification or trigger logic in this story",
        "Typecheck passes"
      ],
      "priority": 25,
      "passes": false,
      "notes": "Groundwork only — full implementation deferred to future PRD"
    }
  ]
}
