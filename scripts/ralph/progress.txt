# Ralph Progress Log
Started: Thu Jan 22 14:33:52 CST 2026
Updated: Sun Jan 26 2026 - New PRD: V2 Bugs and Features
---

## Codebase Patterns
- Evidence data is fetched in `apps/mobile/src/lib/supabase/services/evidence-data.ts`
- Actual event derivation happens in `apps/mobile/src/lib/calendar/actual-display-events.ts`
- Screen time derivation is in `apps/mobile/src/lib/calendar/derive-screen-time-actual-events.ts`
- Calendar orchestration is in `apps/mobile/src/app/comprehensive-calendar.tsx`
- Rendering with absolute positioning is in `apps/mobile/src/components/templates/ComprehensiveCalendarTemplate.tsx`
- Known duplicate key issue at ComprehensiveCalendarTemplate.tsx lines 552-559
- Android location code lives in `apps/mobile/src/lib/android-location/` — index.ts (start/stop/diagnostics), location-task.ts (background task handler), queue.ts (AsyncStorage sample buffer), register.ts (one-time task registration)
- Android location background task uses expo-location + expo-task-manager; task must be defined at module scope per Expo docs
- Location samples are buffered in AsyncStorage (key: `tm:location:pending:{userId}`) then flushed to Supabase via `flushPendingAndroidLocationSamplesToSupabaseAsync()`
- Pre-existing TS errors exist in the codebase (39 total as of Jan 26 2026) — do not block on these; verify your changes don't add new ones
- Event save flow: `actual-adjust.tsx` → `useCalendarEventsSync().createActual()/updateActual()` → `calendar-events.ts` Supabase write → store update. Store updates happen AFTER successful write (no optimistic updates).
- Events with `meta.source: 'actual_adjust'` or `'user'` are protected from: (1) sleep overlap removal in `actual-display-events.ts`, (2) overlap resolution (highest priority), (3) re-derivation in `syncDerivedActualEvents` (time-range overlap check).
- When adding new `CalendarEventMeta.source` values, update the union type in `events-store.ts` and use `as const` on the literal in object literals to prevent TypeScript widening.
- `startAndroidBackgroundLocationAsync()` returns `StartAndroidLocationResult` (typed ok/fail union) — callers should check `.ok` and `.reason`
- `isAndroidBackgroundLocationRunningAsync()` is a lightweight health check for the background task — use it to verify the task is alive without triggering a start
- The sync hook (`use-location-samples-sync.ts`) now has a 5-min health check that auto-restarts the background task with retry backoff (max 3 attempts, reset on foreground)
- `SparseLocationFallback` and `EvidenceAvailability` are PRD conceptual terms — they do not exist as code identifiers in the codebase
- Location data flow: background task → AsyncStorage queue → flush every 2min → `tm.location_samples` → SQL view `tm.location_hourly` (auto-aggregated by PostGIS)
- The local `CalendarEvent` type in ComprehensiveCalendarTemplate.tsx is a narrowed subset of `ScheduledEvent` — if you need `meta`, you must add it to this local type
- To detect "unknown gap" events, always check `meta.kind === 'unknown_gap'` (not just `category === 'unknown'`), because `buildProductiveUnknownEvent` creates events with `category: 'work'` + `kind: 'unknown_gap'`
- Never put entire Zustand store selector objects in useMemo/useCallback dependency arrays — destructure to individual primitive values to avoid spurious recalculations
- `buildActualDisplayEvents` has a module-level fingerprint cache — it returns cached results when inputs are identical (no need to add external memoization)
- `useVerification.refresh()` uses refs for `appCategoryOverrides`, `plannedEvents`, `verificationStrictness`, `onError` to keep a stable callback identity (only depends on `isAuthenticated`, `userId`, `ymd`)
- User-defined places are in `tm.user_places` table (accessed via `UserPlaceRow` type in evidence-data.ts) — already fetched as `evidence.userPlaces` in `EvidenceBundle`. Use `resolveFromUserPlaces()` in actual-display-events.ts to match location labels to user-defined place names before falling back to generic `mapPlaceToCategory`.
- Travel events between locations use `kind: 'travel'` and `category: 'travel'` — minimum gap is 5 min (under 5 min = not travel), maximum 90 min
- When labeling unknown gaps as screen time or productive, require screen time to account for >50% of the block's duration — prevents mislabeling morning routines, church, etc.
- Hierarchical activity categories live in `tm.activity_categories` (self-referencing parent_id). Types are `ActivityCategory`, `ActivityCategoryInsert`, `ActivityCategoryUpdate` exported from `services/activity-categories.ts`. Seed defaults via `tm.seed_default_activity_categories(user_id)`.
- `public.update_updated_at_column()` is a shared trigger function — use it for all tables with `updated_at` columns

## Critical Issue - Android Physical Device
- **Problem**: Evidence data (location, screen time) not pulling on physical Android devices
- **Works**: Android simulator
- **Fails**: Physical Android device via Play Console internal testing (production build)
- **Permissions**: All granted (Usage Access, Location)
- **Symptom**: Nothing being pulled despite permissions granted
- **Priority**: HIGHEST - US-001 and US-002 must be completed first

---

## 2026-01-26 - US-026
- **What was implemented**: Investigated Android location canStart failure. Found and fixed a logic bug in `getAndroidLocationDiagnostics()` where canStart could NEVER be true. Added verbose diagnostic logging throughout the diagnostic function, background task callback, and profile diagnostics display. Added `lastSampleTimestamp` and `sampleCount24h` to diagnostics output.
- **Root cause found**: In `index.ts` line 251 (old code), when `taskStarted=false` and `errors.length === 0`, the code pushed an error "Task not started despite all checks passing - unknown reason". This made `errors.length > 0`, so `canStart = errors.length === 0 && !diagnostics.taskStarted` always evaluated to false. The only scenario where canStart should be true (all checks pass, task not started) was the exact scenario that added a spurious error.
- **Files changed**:
  - `apps/mobile/src/lib/android-location/index.ts` — Fixed canStart logic bug, added verbose `[diag]`-prefixed logging to each diagnostic step, added `lastSampleTimestamp` and `sampleCount24h` fields to diagnostics, added `MAX_PENDING_SAMPLES_PER_USER` constant for full sample peek
  - `apps/mobile/src/lib/android-location/location-task.ts` — Added `[task]`-prefixed logging: task fire timestamp, raw location count, conversion result, authenticated user check, queue result
  - `apps/mobile/src/app/profile.tsx` — Updated diagnostics Alert to show `canStart`, `lastSampleTimestamp`, and `sampleCount24h` fields
- **Learnings for future iterations:**
  - The canStart logic was self-contradictory: it treated "task not started despite checks passing" as an error, but that's the normal state when the app should start the task. Future logic should distinguish "informational" vs "blocking" issues.
  - Background task error logging was gated behind `__DEV__` — the catch block in defineTask only logged in dev mode. Changed the catch to always log since background task failures are critical.
  - Location task fires asynchronously by the Android system — adding timestamp logging is critical to verify it actually fires.
  - `peekPendingAndroidLocationSamplesAsync` with limit=1000 missed samples beyond that; changed to MAX_PENDING_SAMPLES_PER_USER (10000) for accurate diagnostics.
  - Pre-existing TS errors: `PermissionStatus` type mismatch at lines 46/98 — string literal `'denied'` doesn't match enum. Not blocking; don't fix in unrelated stories.
---

## 2026-01-26 - US-027
- **What was implemented**: Fixed Android location background collection by adding robust start result reporting, production logging, error handling, and automatic health-check/restart mechanism.
- **Changes to `apps/mobile/src/lib/android-location/index.ts`**:
  - Changed `startAndroidBackgroundLocationAsync()` return type from `Promise<void>` to `Promise<StartAndroidLocationResult>` — a discriminated union with `ok: true/false` and specific `reason` strings
  - Added `console.log` on every early-return path (support, module, services, fg permission, bg permission) — these are NOT gated behind `__DEV__` so they appear in production logs
  - Wrapped `Location.startLocationUpdatesAsync()` in try/catch to handle native module failures gracefully, returning `{ ok: false, reason: 'start_failed', detail }` instead of throwing
  - Added `isAndroidBackgroundLocationRunningAsync()` — lightweight check of whether the background task is running, used by the health check
- **Changes to `apps/mobile/src/lib/supabase/hooks/use-location-samples-sync.ts`**:
  - Updated auth-change start handler to use the typed result, logging failures with reason and detail
  - Added new `useEffect` for Android health check: runs every 5 minutes and on app foreground
  - Health check calls `isAndroidBackgroundLocationRunningAsync()`, and if task is stopped, attempts `startAndroidBackgroundLocationAsync()`
  - Retry backoff: max 3 consecutive restart attempts (via `retryAttemptsRef`), then backs off until next foreground event when the counter resets
- **Files changed**:
  - `apps/mobile/src/lib/android-location/index.ts` — New result type, production logging, error handling, health check helper
  - `apps/mobile/src/lib/supabase/hooks/use-location-samples-sync.ts` — Health check effect, retry backoff, typed result handling
- **Learnings for future iterations:**
  - `SparseLocationFallback`, `EvidenceAvailability`, and `EvidenceFusion` are PRD conceptual terms that do not exist as code identifiers. Don't search for them in code.
  - `tm.location_hourly` is a SQL view (not a table) — it auto-aggregates from `tm.location_samples` using PostGIS. No ETL or sync job needed.
  - The sync hook already had two AppState listeners (flush + health check). Each needs its own cleanup. Keep effects separate rather than combining to avoid complexity.
  - When using TypeScript discriminated unions with optional properties (`detail` only on the error variant), access via `'detail' in result ? result.detail : undefined` to satisfy the compiler.
  - The existing codebase uses `void functionCall()` for fire-and-forget async calls — this pattern still works when the return type changes from `void` to a result type, since `void` discards the value.
- Android `UsageStatsManager.queryUsageStats(INTERVAL_DAILY)` often returns `totalTimeInForeground=0` on physical devices because stats aren't aggregated until end-of-day on many OEMs. Always fall back to summing session durations from `queryEvents()`.
- `syncAndroidUsageSummary` must persist sessions AND hourlyByApp data to Supabase (not just daily totals and app daily rows) — otherwise the evidence pipeline and screen-time-app-sessions queries return empty data for Android
- The Android UsageSummary has `sessions[].startIso/endIso/packageName/durationSeconds` while iOS has `appSessions[].startedAtIso/endedAtIso/bundleIdentifier/durationSeconds` — different field names for the same concept
---

## 2026-01-26 - US-028
- **What was implemented**: Fixed two root causes of the "5 sessions, 0 min" Android screen time bug.
- **Root cause 1 (Kotlin — AndroidInsightsModule.kt)**: `queryUsageStats(INTERVAL_DAILY)` returns `totalTimeInForeground=0` on many Android OEMs because aggregate stats aren't computed until end-of-day. Meanwhile, `queryEvents()` returns real-time foreground/background events and sessions with correct durations. The fix: when `totalSeconds == 0` but sessions exist, sum `durationSeconds` from all sessions to compute `totalSeconds`, and rebuild `topApps` from session data using the new `buildTopAppsFromSessions()` helper.
- **Root cause 2 (TypeScript — screen-time-sync.ts)**: `syncAndroidUsageSummary` was calling `replaceAppSessions(dailyId, [])` — always passing an empty array, so no Android sessions were persisted to Supabase. It also never wrote `screen_time_app_hourly` data. The fix: map Android `UsageSummary.sessions[]` to `ScreenTimeAppSessionInsert[]` and persist them, and map `hourlyByApp` to `ScreenTimeAppHourlyInsert[]` rows.
- **Logging added**: Kotlin `Log.d("AndroidInsights", ...)` logs aggregate stats count, totalSeconds, sessions count, hourly buckets sum. TypeScript `console.log("[insights-sync]")` logs summary stats before sync.
- **Files changed**:
  - `apps/mobile/modules/android-insights/android/src/main/java/expo/modules/androidinsights/AndroidInsightsModule.kt` — Added `import android.util.Log`, changed `appArray` from `val` to `var`, added session-based `totalSeconds` fallback and `buildTopAppsFromSessions()` helper, added production logging
  - `apps/mobile/src/lib/supabase/services/screen-time-sync.ts` — `syncAndroidUsageSummary` now maps and persists Android sessions to `screen_time_app_sessions` and hourlyByApp data to `screen_time_app_hourly`
  - `apps/mobile/src/lib/supabase/hooks/use-insights-sync.ts` — Added `console.log` for Android usage summary stats before sync
- **Learnings for future iterations:**
  - Android `queryUsageStats` aggregate data can return 0 for `totalTimeInForeground` even when the user has been actively using apps — this is an OEM/timing issue. Always have a fallback to event-based (`queryEvents`) data.
  - The `buildUsageHourlyBucketsSeconds` function creates sessions from foreground/background event pairs. These sessions have correct durations even when aggregate stats are empty.
  - When `totalSeconds` is computed from sessions, the existing fallback `if (hourlyBuckets.sum() == 0L && totalSeconds > 0L)` then fires correctly to rebuild hourly buckets from stats. However, if both aggregate stats AND hourly buckets are empty, the hourly data comes from session-based `hourlyByApp` which is already populated by `buildUsageHourlyBucketsSeconds`.
  - The iOS and Android screen time data have different type shapes (`ScreenTimeSummary` vs `UsageSummary`, `appSessions` vs `sessions`, `bundleIdentifier` vs `packageName`). The sync functions need to handle these independently.
  - `screen_time_app_sessions` is queried by `evidence-data.ts::fetchScreenTimeSessionsForDay()` for the evidence pipeline — if sessions aren't persisted, the entire evidence-based screen time detection is blind on Android.
---

## 2026-01-26 - US-029
- **What was implemented**: Fixed event edit persistence — diagnosed and fixed three issues causing edits to appear to "revert" after saving.
- **Root cause analysis**: The save flow in `actual-adjust.tsx` was architecturally correct (store updates happen only after successful Supabase write), but had three issues:
  1. **Silent failure on save error**: The outer catch block (line 462) only logged in `__DEV__` mode and showed NO user-facing error. If Supabase write failed, the user got no feedback and `router.back()` was never called — but since the store wasn't updated either, navigating back showed old data, making it look like the edit "reverted."
  2. **TypeScript type mismatch**: `source: 'actual_adjust'` was set in the meta object, but `CalendarEventMeta.source` only allowed `'user' | 'system' | 'evidence' | 'derived'`. The literal was widened to `string` at runtime (accepted as JSON), but TypeScript flagged it as an error.
  3. **Re-derivation overwrite risk**: When a user edits a derived event (ID like `derived_actual:xxx`), `actual-adjust.tsx` creates a NEW event via `createActual()` with a fresh UUID. But `syncDerivedActualEvents` could re-create the original derived event on the next sync cycle if the time range/kind didn't exactly match (e.g., user changed the time).
- **Fixes applied**:
  - `actual-adjust.tsx`: Added `Alert.alert('Save failed', ...)` in the outer catch block (always shown, not just `__DEV__`). Changed `source: 'actual_adjust'` to `source: 'actual_adjust' as const` to fix TypeScript type widening.
  - `events-store.ts`: Added `'actual_adjust'` to the `CalendarEventMeta.source` union type.
  - `calendar-events.ts` (`syncDerivedActualEvents`): Added tracking of user-edited event time ranges (`source: 'actual_adjust'` or `source: 'user'`), and added an overlap check that skips derived event insertion if it overlaps any user-edited event.
- **Verified correct existing behavior**:
  - `updateActual()` in `calendar-events.ts` correctly calls Supabase `.update().eq('id', eventId).select('*').single()` and returns the mapped `ScheduledEvent`.
  - Store updates (`updateActualEvent`/`addActualEvent`) happen only AFTER the `await createActual()` / `await updateActual()` calls succeed.
  - `buildActualDisplayEvents` in `actual-display-events.ts` already protects events with `source: 'actual_adjust'` — they are skipped during sleep overlap removal and given highest priority in overlap resolution sorting.
  - `source: 'actual_adjust'` was already being set in meta (line 387), so the acceptance criteria for adding it was already met.
- **Files changed**:
  - `apps/mobile/src/app/actual-adjust.tsx` — Added user-visible Alert on save failure, added `as const` for source literal
  - `apps/mobile/src/stores/events-store.ts` — Added `'actual_adjust'` to CalendarEventMeta.source type union
  - `apps/mobile/src/lib/supabase/services/calendar-events.ts` — `syncDerivedActualEvents` now tracks user-edited event time ranges and skips derived events that overlap them
- **Learnings for future iterations:**
  - The save flow correctly uses await-then-store pattern (no optimistic updates). Edits persist because: (1) `await createActual()`/`updateActual()` writes to Supabase, (2) the returned ScheduledEvent is then stored locally via `addActualEvent()`/`updateActualEvent()`. If step 1 fails, step 2 never runs.
  - `CalendarEventMeta.source` type must include all source values used in the codebase. When adding a new source, update the union in `events-store.ts`.
  - TypeScript widens string literals in object literals. Use `as const` on the literal value to keep narrow types, rather than annotating the entire object.
  - `syncDerivedActualEvents` can re-create derived events that a user has already edited if the overlap check isn't robust. The fix adds time-range overlap checking against `source: 'actual_adjust'` and `source: 'user'` events.
  - The `shouldCreate` check in actual-adjust.tsx (lines 410-413) creates new events for derived IDs. This is correct — derived events are ephemeral display IDs; the user edit creates a permanent Supabase record.
---

## 2026-01-26 - US-030
- **What was implemented**: Made all unknown_gap events fully tappable and editable. Previously, "Productive" events (which have `meta.kind: 'unknown_gap'` but `category: 'work'`) were blocked from editing in the planned column because `handleOpenEditor` only checked `category === 'unknown'`, and `TimeEventBlock.handlePress` only routed to review-time for `category === 'unknown'`. Events with `kind: 'unknown_gap'` but different categories fell through to `handleOpenEditor` which blocked all derived non-unknown events.
- **Root causes found**:
  1. **CalendarEvent type too narrow**: The local `CalendarEvent` type in ComprehensiveCalendarTemplate.tsx lacked the `meta` field, so kind-based checks were impossible at the type level.
  2. **isUnknown only checked category**: `isUnknown = event.category === 'unknown'` missed events like "Productive" which have `kind: 'unknown_gap'` but `category: 'work'`.
  3. **handleOpenEditor blocked derived non-unknown**: The guard `event.category !== 'unknown'` blocked Productive events (category: 'work') even though they have `kind: 'unknown_gap'`.
- **Fixes applied**:
  - Added `meta?: CalendarEventMeta` to local `CalendarEvent` type and imported `CalendarEventMeta`
  - Expanded `isUnknown` to: `event.category === 'unknown' || event.meta?.kind === 'unknown_gap'`
  - Added direct actual-adjust routing for all `unknown_gap` kind events in `TimeEventBlock.handlePress()` — these now bypass the review-time shortcut entirely
  - Updated `handleOpenEditor` guard to also check `event.meta?.kind !== 'unknown_gap'`
- **Persistence verification**: Editing already uses `source: 'actual_adjust' as const` in actual-adjust.tsx. After save, `buildActualDisplayEvents` overlap check suppresses the original derived Unknown event.
- **Files changed**:
  - `apps/mobile/src/components/templates/ComprehensiveCalendarTemplate.tsx` — Added CalendarEventMeta import, meta field to CalendarEvent type, expanded isUnknown check, added unknown_gap direct routing in handlePress, updated handleOpenEditor guard
- **Learnings for future iterations:**
  - The local `CalendarEvent` type in ComprehensiveCalendarTemplate.tsx is a subset of `ScheduledEvent`. When adding meta-based checks, the type must be updated to include `meta`.
  - `buildProductiveUnknownEvent` creates events with `category: 'work'` but `kind: 'unknown_gap'` — always check `meta.kind` when determining if an event is an "unknown gap", not just `category`.
  - Unknown_gap events should always route to actual-adjust for full editing (title, time, category), not to the simpler review-time interface.
  - The planned column uses `handleOpenEditor` for inline editing, but unknown_gap events benefit from the full actual-adjust screen. Routing them directly prevents confusion.
---

## 2026-01-26 - US-031
- **What was implemented**: Fixed evidence pipeline re-processing loop. The pipeline was running 8+ times per cycle due to three cascading issues in React dependency management and lack of memoization.
- **Root cause 1 (comprehensive-calendar.tsx)**: The `combinedActualEvents` useMemo (line 491) included the entire `userPreferences` object in its dependency array, but only used 3 primitive fields (`gapFillingPreference`, `confidenceThreshold`, `autoSuggestEvents`). Any Zustand store mutation created a new `userPreferences` reference, triggering full pipeline recalculation even when relevant preferences hadn't changed. Fix: extracted the 3 fields into local variables and used them as individual deps.
- **Root cause 2 (use-verification.ts)**: The `refresh()` callback (which fetches evidence AND runs verification) and the re-verification effect both ran `verifyPlannedEvents()` + `generateActualBlocks()`. When `refresh()` set new `evidence` state, the re-verification effect fired again because `evidence` was in its dependency array — running the same computation a second time. Fix: added `lastVerificationInputs` fingerprint ref. After `refresh()` computes verification, it stores the fingerprint. The re-verification effect checks fingerprint before computing, and skips if it matches.
- **Root cause 3 (use-verification.ts)**: The `refresh` callback had `appCategoryOverrides`, `plannedEvents`, `verificationStrictness`, and `onError` in its dependency array. When any of these changed, `refresh` got a new identity, which triggered the auto-fetch effect (which depends on `refresh`). Even though `lastFetched` prevented re-fetching, the callback recreation caused React to re-render. Fix: moved these values to stable refs (`appCategoryOverridesRef`, `plannedEventsRef`, etc.) accessed inside the callback, reducing deps to `[isAuthenticated, userId, ymd, buildVerificationFingerprint]`.
- **Additional defense (actual-display-events.ts)**: Added module-level fingerprint cache (`_lastPipelineFingerprint` + `_lastPipelineResult`) to `buildActualDisplayEvents`. Before running the full pipeline, it computes a string fingerprint of all inputs (event IDs/times, evidence counts, preference values, etc.) and returns the cached result if the fingerprint matches. This provides a last-line defense against redundant computation even if React deps fire spuriously.
- **Files changed**:
  - `apps/mobile/src/app/comprehensive-calendar.tsx` — Decomposed `userPreferences` object into individual primitive deps in useMemo
  - `apps/mobile/src/lib/calendar/use-verification.ts` — Added fingerprint tracking for re-verification skip, stable refs for refresh callback deps, reduced callback dependency array
  - `apps/mobile/src/lib/calendar/actual-display-events.ts` — Added `buildPipelineFingerprint()` and module-level cache for input-based deduplication
- **Learnings for future iterations:**
  - Zustand stores return new object references on ANY mutation. Never put an entire store selector object in a useMemo dependency array — always destructure to individual primitive values.
  - When a useCallback fetches data AND processes it (setting multiple states), downstream useEffects that depend on those states will fire redundantly. Use fingerprint refs to deduplicate.
  - Moving values to refs breaks the React dependency chain intentionally — use this pattern when a callback needs current values but shouldn't re-create when they change (because re-creation causes cascading effects).
  - Module-level caches (outside React) are a useful last-line defense for pure functions called from useMemo — they work even when React deps fire spuriously.
  - `SparseLocationFallback`, `EvidenceAvailability`, `EvidenceFusion` log lines come from `buildActualDisplayEvents` sub-functions. Reducing pipeline runs directly reduces these log lines.
- `location_hourly` is a SQL view using `date_trunc('hour', recorded_at)` — all timestamps snap to :00. To get precise timing, fetch raw `location_samples.recorded_at` and use them to refine boundaries.
- When converting a `Date` to minutes-from-midnight, use `Math.round(hours*60 + minutes + seconds/60)` instead of `hours*60 + minutes` to preserve nearest-minute accuracy.
- `EvidenceBundle.locationSamples` contains raw sample timestamps for precise location block boundaries; `locationHourly` contains place labels and categories.
---

## 2026-01-26 - US-032
- **What was implemented**: Fixed event time accuracy by eliminating two sources of time rounding/bucketing.
- **Root cause 1 (buildLocationBlocks)**: The `buildLocationBlocks` function in `actual-display-events.ts` created location blocks by parsing `location_hourly` view rows. Since `location_hourly` uses SQL `date_trunc('hour', recorded_at)`, all `hour_start` values are snapped to hour boundaries (e.g., 9:00, 10:00). The function then assumed each block spanned exactly 60 minutes (`startMinutes + 60`). This meant if a user arrived at a location at 9:32, the event would show starting at 9:00. **Fix**: Added `fetchLocationSamplesForDay()` to fetch raw `location_samples` with precise `recorded_at` timestamps. In `buildLocationBlocks`, built a lookup map of `hour → { first sample minute, last sample minute }` from raw samples, then used these precise boundaries instead of the hour boundary + 60. Adjacent blocks merge with a 1-minute tolerance.
- **Root cause 2 (session time truncation)**: Six locations in `actual-display-events.ts` converted `Date` objects to minutes-from-midnight using `start.getHours() * 60 + start.getMinutes()`, which truncates seconds (9:32:45 → 572.0 instead of 573). **Fix**: Added `dateToMinutes()` helper that uses `Math.round(hours*60 + minutes + seconds/60)` for nearest-minute precision, and replaced all 6 occurrences.
- **Audit results for evidence-fusion.ts**: Clean — no timestamp rounding or bucketing. It only computes confidence scores from verification/data-quality/pattern data, not timestamps.
- **Calendar-sourced events**: Already correct — `buildPlannedActualEvent` uses `planned.startMinutes` directly with `clampMinutes()` (no rounding).
- **Debug logging added**: `buildLocationBlocks` now logs block count, raw sample count, and each block's precise start/end minutes for runtime verification.
- **Files changed**:
  - `apps/mobile/src/lib/supabase/services/evidence-data.ts` — Added `EvidenceLocationSample` type, `fetchLocationSamplesForDay()` function, added `locationSamples` to `EvidenceBundle`, updated `fetchAllEvidenceForDay()` to fetch raw samples in parallel
  - `apps/mobile/src/lib/calendar/actual-display-events.ts` — Rewrote `buildLocationBlocks` to use raw sample timestamps for precise boundaries, added `dateToMinutes()` helper, replaced 6 occurrences of truncating `getHours()*60+getMinutes()` pattern, updated pipeline fingerprint to include `locationSamples` count
- **Learnings for future iterations:**
  - `location_hourly` view uses `date_trunc('hour', recorded_at)` which snaps all timestamps to hour boundaries. For precise timing, always use raw `location_samples.recorded_at`.
  - `Date.getHours()*60 + Date.getMinutes()` truncates seconds. Use `Math.round(hours*60 + minutes + seconds/60)` for nearest-minute accuracy.
  - When adding new types to `evidence-data.ts`, avoid naming conflicts with existing `location-samples.ts` types — both are re-exported from `services/index.ts`.
  - The `EvidenceBundle` type is used across many files but only constructed in `fetchAllEvidenceForDay()`. Adding new fields is safe as long as you update that single constructor.
---

## 2026-01-26 - US-033
- **What was implemented**: Fixed event inference to stop mislabeling blocks as screen time when the user wasn't actively using their phone. Added user-defined place recognition, travel detection, and >50% screen time threshold.
- **Root cause 1 (Aggressive productive labeling)**: `replaceUnknownWithProductiveUsage()` converted unknown gaps to "Productive" events whenever ANY productive app usage existed in the time range, regardless of how much of the block was actually phone use. A 60-minute morning routine with 5 minutes of phone checks would be labeled as "Productive Screen Time". Fix: Added `usageInfo.totalMinutes <= blockDuration * 0.5` check — screen time must account for >50% of the block's duration before relabeling.
- **Root cause 2 (No user place matching)**: `buildLocationEvent()` used `mapPlaceToCategory()` for generic keyword-based inference (e.g., "church" → routine), but never checked the user's own place definitions (`tm.user_places`). So even labeled places fell through to generic matching. Fix: Added `resolveFromUserPlaces()` which checks `evidence.userPlaces` first. User labels take priority. Added `mapPlaceCategoryString()` to convert user-defined category strings to `EventCategory` values.
- **Root cause 3 (No travel recognition)**: The pipeline detected location changes between stationary points but labeled them as "Commute"/"Driving" with `category: 'comm'` and `kind: 'transition_commute'`. Fix: Changed to `category: 'travel'`, `kind: 'travel'`, with descriptive titles like "Travel: Home → Church". Also lowered minimum travel gap from 15 to 5 minutes (matching AC: <5 min movements within same area are NOT flagged as travel). Added `'travel'` to `CalendarEventMeta.kind` union type.
- **Threading userPlaces through the pipeline**: `EvidenceBundle.userPlaces` was already fetched but unused. Added `userPlaces` to `LocationReplacementContext` interface, passed `evidence?.userPlaces` through from `buildActualDisplayEvents`, and used it in `buildLocationEvent` → `resolveLocationDetails` → `resolveFromUserPlaces`.
- **Files changed**:
  - `apps/mobile/src/stores/events-store.ts` — Added `'travel'` to `CalendarEventMeta.kind` union type
  - `apps/mobile/src/lib/calendar/actual-display-events.ts` — Added `UserPlaceRow` import, `userPlaces` to `LocationReplacementContext`, >50% threshold in `replaceUnknownWithProductiveUsage`, `resolveFromUserPlaces()` + `mapPlaceCategoryString()` helpers, updated `resolveLocationDetails` to check user places first, changed commute events to travel (`kind: 'travel'`, `category: 'travel'`), lowered travel min gap from 15 to 5 min
- **Learnings for future iterations:**
  - `tm.user_places` is already fetched in `EvidenceBundle` via `fetchUserPlaces()` — no need to add a separate fetch. Just thread `evidence.userPlaces` to any function that needs it.
  - `mapPlaceToCategory` uses keyword matching on the combined `${locationLabel} ${placeCategory}` string. This is fragile — user-defined places should always take priority.
  - When changing event kinds/categories for travel, also update the ID prefix to avoid collisions (e.g., `commute_` → `travel_`).
  - The pipeline has layered gap-filling: sleep → location → productive usage → transitions → prep/wind-down → patterns. Each layer only touches `category: 'unknown'` events. The >50% threshold in productive usage prevents over-labeling at that layer.
  - `EventCategory` already includes `'travel'` (line 14 of events-store.ts), but `CalendarEventMeta.kind` did not — always check both when adding a new activity type.
---

## 2026-01-26 - US-034
- **What was implemented**: Created hierarchical activity categories database schema and TypeScript types. This replaces the flat `EventCategory` enum with a user-owned tree structure supporting Category → Subcategory → Sub-subcategory.
- **Migration (`20260126_create_tm_activity_categories.sql`)**:
  - Table `tm.activity_categories`: id (UUID PK), user_id (FK → auth.users), parent_id (nullable self-referencing FK → activity_categories, cascade delete), name, icon, color, sort_order, created_at, updated_at
  - Unique constraint `(user_id, parent_id, name)` prevents duplicate categories at same hierarchy level
  - Indexes on user_id, parent_id, and (user_id, parent_id, sort_order) for common query patterns
  - `updated_at` trigger using existing `public.update_updated_at_column()` function
  - RLS policies: select/insert/update/delete own rows (idempotent DO block pattern)
  - `seed_default_activity_categories(p_user_id)` SQL function — creates 7 default top-level categories (Faith, Family, Work, Health, Personal Growth, Finances, Other) idempotently (skips if user already has categories)
- **TypeScript types (`activity-categories.ts`)**:
  - `ActivityCategory` = Row type from `Database['tm']['Tables']['activity_categories']`
  - `ActivityCategoryInsert` = Insert type
  - `ActivityCategoryUpdate` = Update type
  - All derived from `database.types.ts` to stay in sync with schema
- **database.types.ts updated**: Added `activity_categories` table definition to `tm.Tables` with Row/Insert/Update/Relationships, and `seed_default_activity_categories` to `tm.Functions`
- **Exported from** `services/index.ts`
- **Files changed**:
  - `supabase/migrations/20260126_create_tm_activity_categories.sql` — New migration
  - `apps/mobile/src/lib/supabase/database.types.ts` — Added activity_categories table type and seed function type
  - `apps/mobile/src/lib/supabase/services/activity-categories.ts` — New service file with exported types
  - `apps/mobile/src/lib/supabase/services/index.ts` — Added re-export
- **Learnings for future iterations:**
  - `public.update_updated_at_column()` is a shared trigger function already available in the database — use it for all tables with `updated_at` columns
  - Self-referencing FKs with `ON DELETE CASCADE` handle subtree deletion automatically — deleting a parent category cascades to all children at all levels
  - The unique constraint `(user_id, parent_id, name)` uses NULL for parent_id on top-level categories. PostgreSQL treats NULLs as distinct in unique constraints, so this works correctly: two users can both have a top-level "Work" category
  - Seed functions using `SECURITY DEFINER` bypass RLS — necessary for server-side/admin seeding. The function is idempotent (checks for existing categories first).
  - Database types are defined in `database.types.ts` following Row/Insert/Update pattern. Service files should derive types from this file using `Database['tm']['Tables']['table_name']` for type safety.
---
