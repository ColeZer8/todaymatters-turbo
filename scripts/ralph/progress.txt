# Ralph Progress Log
Started: Thu Jan 22 14:33:52 CST 2026
Updated: Sun Jan 26 2026 - New PRD: V2 Bugs and Features
---

## Codebase Patterns
- Evidence data is fetched in `apps/mobile/src/lib/supabase/services/evidence-data.ts`
- Actual event derivation happens in `apps/mobile/src/lib/calendar/actual-display-events.ts`
- Screen time derivation is in `apps/mobile/src/lib/calendar/derive-screen-time-actual-events.ts`
- Calendar orchestration is in `apps/mobile/src/app/comprehensive-calendar.tsx`
- Rendering with absolute positioning is in `apps/mobile/src/components/templates/ComprehensiveCalendarTemplate.tsx`
- Known duplicate key issue at ComprehensiveCalendarTemplate.tsx lines 552-559
- Android location code lives in `apps/mobile/src/lib/android-location/` — index.ts (start/stop/diagnostics), location-task.ts (background task handler), queue.ts (AsyncStorage sample buffer), register.ts (one-time task registration)
- Android location background task uses expo-location + expo-task-manager; task must be defined at module scope per Expo docs
- Location samples are buffered in AsyncStorage (key: `tm:location:pending:{userId}`) then flushed to Supabase via `flushPendingAndroidLocationSamplesToSupabaseAsync()`
- Pre-existing TS errors exist in the codebase (39 total as of Jan 26 2026) — do not block on these; verify your changes don't add new ones
- Event save flow: `actual-adjust.tsx` → `useCalendarEventsSync().createActual()/updateActual()` → `calendar-events.ts` Supabase write → store update. Store updates happen AFTER successful write (no optimistic updates).
- Events with `meta.source: 'actual_adjust'` or `'user'` are protected from: (1) sleep overlap removal in `actual-display-events.ts`, (2) overlap resolution (highest priority), (3) re-derivation in `syncDerivedActualEvents` (time-range overlap check).
- When adding new `CalendarEventMeta.source` values, update the union type in `events-store.ts` and use `as const` on the literal in object literals to prevent TypeScript widening.
- `startAndroidBackgroundLocationAsync()` returns `StartAndroidLocationResult` (typed ok/fail union) — callers should check `.ok` and `.reason`
- `isAndroidBackgroundLocationRunningAsync()` is a lightweight health check for the background task — use it to verify the task is alive without triggering a start
- The sync hook (`use-location-samples-sync.ts`) now has a 5-min health check that auto-restarts the background task with retry backoff (max 3 attempts, reset on foreground)
- `SparseLocationFallback` and `EvidenceAvailability` are PRD conceptual terms — they do not exist as code identifiers in the codebase
- Location data flow: background task → AsyncStorage queue → flush every 2min → `tm.location_samples` → SQL view `tm.location_hourly` (auto-aggregated by PostGIS)

## Critical Issue - Android Physical Device
- **Problem**: Evidence data (location, screen time) not pulling on physical Android devices
- **Works**: Android simulator
- **Fails**: Physical Android device via Play Console internal testing (production build)
- **Permissions**: All granted (Usage Access, Location)
- **Symptom**: Nothing being pulled despite permissions granted
- **Priority**: HIGHEST - US-001 and US-002 must be completed first

---

## 2026-01-26 - US-026
- **What was implemented**: Investigated Android location canStart failure. Found and fixed a logic bug in `getAndroidLocationDiagnostics()` where canStart could NEVER be true. Added verbose diagnostic logging throughout the diagnostic function, background task callback, and profile diagnostics display. Added `lastSampleTimestamp` and `sampleCount24h` to diagnostics output.
- **Root cause found**: In `index.ts` line 251 (old code), when `taskStarted=false` and `errors.length === 0`, the code pushed an error "Task not started despite all checks passing - unknown reason". This made `errors.length > 0`, so `canStart = errors.length === 0 && !diagnostics.taskStarted` always evaluated to false. The only scenario where canStart should be true (all checks pass, task not started) was the exact scenario that added a spurious error.
- **Files changed**:
  - `apps/mobile/src/lib/android-location/index.ts` — Fixed canStart logic bug, added verbose `[diag]`-prefixed logging to each diagnostic step, added `lastSampleTimestamp` and `sampleCount24h` fields to diagnostics, added `MAX_PENDING_SAMPLES_PER_USER` constant for full sample peek
  - `apps/mobile/src/lib/android-location/location-task.ts` — Added `[task]`-prefixed logging: task fire timestamp, raw location count, conversion result, authenticated user check, queue result
  - `apps/mobile/src/app/profile.tsx` — Updated diagnostics Alert to show `canStart`, `lastSampleTimestamp`, and `sampleCount24h` fields
- **Learnings for future iterations:**
  - The canStart logic was self-contradictory: it treated "task not started despite checks passing" as an error, but that's the normal state when the app should start the task. Future logic should distinguish "informational" vs "blocking" issues.
  - Background task error logging was gated behind `__DEV__` — the catch block in defineTask only logged in dev mode. Changed the catch to always log since background task failures are critical.
  - Location task fires asynchronously by the Android system — adding timestamp logging is critical to verify it actually fires.
  - `peekPendingAndroidLocationSamplesAsync` with limit=1000 missed samples beyond that; changed to MAX_PENDING_SAMPLES_PER_USER (10000) for accurate diagnostics.
  - Pre-existing TS errors: `PermissionStatus` type mismatch at lines 46/98 — string literal `'denied'` doesn't match enum. Not blocking; don't fix in unrelated stories.
---

## 2026-01-26 - US-027
- **What was implemented**: Fixed Android location background collection by adding robust start result reporting, production logging, error handling, and automatic health-check/restart mechanism.
- **Changes to `apps/mobile/src/lib/android-location/index.ts`**:
  - Changed `startAndroidBackgroundLocationAsync()` return type from `Promise<void>` to `Promise<StartAndroidLocationResult>` — a discriminated union with `ok: true/false` and specific `reason` strings
  - Added `console.log` on every early-return path (support, module, services, fg permission, bg permission) — these are NOT gated behind `__DEV__` so they appear in production logs
  - Wrapped `Location.startLocationUpdatesAsync()` in try/catch to handle native module failures gracefully, returning `{ ok: false, reason: 'start_failed', detail }` instead of throwing
  - Added `isAndroidBackgroundLocationRunningAsync()` — lightweight check of whether the background task is running, used by the health check
- **Changes to `apps/mobile/src/lib/supabase/hooks/use-location-samples-sync.ts`**:
  - Updated auth-change start handler to use the typed result, logging failures with reason and detail
  - Added new `useEffect` for Android health check: runs every 5 minutes and on app foreground
  - Health check calls `isAndroidBackgroundLocationRunningAsync()`, and if task is stopped, attempts `startAndroidBackgroundLocationAsync()`
  - Retry backoff: max 3 consecutive restart attempts (via `retryAttemptsRef`), then backs off until next foreground event when the counter resets
- **Files changed**:
  - `apps/mobile/src/lib/android-location/index.ts` — New result type, production logging, error handling, health check helper
  - `apps/mobile/src/lib/supabase/hooks/use-location-samples-sync.ts` — Health check effect, retry backoff, typed result handling
- **Learnings for future iterations:**
  - `SparseLocationFallback`, `EvidenceAvailability`, and `EvidenceFusion` are PRD conceptual terms that do not exist as code identifiers. Don't search for them in code.
  - `tm.location_hourly` is a SQL view (not a table) — it auto-aggregates from `tm.location_samples` using PostGIS. No ETL or sync job needed.
  - The sync hook already had two AppState listeners (flush + health check). Each needs its own cleanup. Keep effects separate rather than combining to avoid complexity.
  - When using TypeScript discriminated unions with optional properties (`detail` only on the error variant), access via `'detail' in result ? result.detail : undefined` to satisfy the compiler.
  - The existing codebase uses `void functionCall()` for fire-and-forget async calls — this pattern still works when the return type changes from `void` to a result type, since `void` discards the value.
- Android `UsageStatsManager.queryUsageStats(INTERVAL_DAILY)` often returns `totalTimeInForeground=0` on physical devices because stats aren't aggregated until end-of-day on many OEMs. Always fall back to summing session durations from `queryEvents()`.
- `syncAndroidUsageSummary` must persist sessions AND hourlyByApp data to Supabase (not just daily totals and app daily rows) — otherwise the evidence pipeline and screen-time-app-sessions queries return empty data for Android
- The Android UsageSummary has `sessions[].startIso/endIso/packageName/durationSeconds` while iOS has `appSessions[].startedAtIso/endedAtIso/bundleIdentifier/durationSeconds` — different field names for the same concept
---

## 2026-01-26 - US-028
- **What was implemented**: Fixed two root causes of the "5 sessions, 0 min" Android screen time bug.
- **Root cause 1 (Kotlin — AndroidInsightsModule.kt)**: `queryUsageStats(INTERVAL_DAILY)` returns `totalTimeInForeground=0` on many Android OEMs because aggregate stats aren't computed until end-of-day. Meanwhile, `queryEvents()` returns real-time foreground/background events and sessions with correct durations. The fix: when `totalSeconds == 0` but sessions exist, sum `durationSeconds` from all sessions to compute `totalSeconds`, and rebuild `topApps` from session data using the new `buildTopAppsFromSessions()` helper.
- **Root cause 2 (TypeScript — screen-time-sync.ts)**: `syncAndroidUsageSummary` was calling `replaceAppSessions(dailyId, [])` — always passing an empty array, so no Android sessions were persisted to Supabase. It also never wrote `screen_time_app_hourly` data. The fix: map Android `UsageSummary.sessions[]` to `ScreenTimeAppSessionInsert[]` and persist them, and map `hourlyByApp` to `ScreenTimeAppHourlyInsert[]` rows.
- **Logging added**: Kotlin `Log.d("AndroidInsights", ...)` logs aggregate stats count, totalSeconds, sessions count, hourly buckets sum. TypeScript `console.log("[insights-sync]")` logs summary stats before sync.
- **Files changed**:
  - `apps/mobile/modules/android-insights/android/src/main/java/expo/modules/androidinsights/AndroidInsightsModule.kt` — Added `import android.util.Log`, changed `appArray` from `val` to `var`, added session-based `totalSeconds` fallback and `buildTopAppsFromSessions()` helper, added production logging
  - `apps/mobile/src/lib/supabase/services/screen-time-sync.ts` — `syncAndroidUsageSummary` now maps and persists Android sessions to `screen_time_app_sessions` and hourlyByApp data to `screen_time_app_hourly`
  - `apps/mobile/src/lib/supabase/hooks/use-insights-sync.ts` — Added `console.log` for Android usage summary stats before sync
- **Learnings for future iterations:**
  - Android `queryUsageStats` aggregate data can return 0 for `totalTimeInForeground` even when the user has been actively using apps — this is an OEM/timing issue. Always have a fallback to event-based (`queryEvents`) data.
  - The `buildUsageHourlyBucketsSeconds` function creates sessions from foreground/background event pairs. These sessions have correct durations even when aggregate stats are empty.
  - When `totalSeconds` is computed from sessions, the existing fallback `if (hourlyBuckets.sum() == 0L && totalSeconds > 0L)` then fires correctly to rebuild hourly buckets from stats. However, if both aggregate stats AND hourly buckets are empty, the hourly data comes from session-based `hourlyByApp` which is already populated by `buildUsageHourlyBucketsSeconds`.
  - The iOS and Android screen time data have different type shapes (`ScreenTimeSummary` vs `UsageSummary`, `appSessions` vs `sessions`, `bundleIdentifier` vs `packageName`). The sync functions need to handle these independently.
  - `screen_time_app_sessions` is queried by `evidence-data.ts::fetchScreenTimeSessionsForDay()` for the evidence pipeline — if sessions aren't persisted, the entire evidence-based screen time detection is blind on Android.
---

## 2026-01-26 - US-029
- **What was implemented**: Fixed event edit persistence — diagnosed and fixed three issues causing edits to appear to "revert" after saving.
- **Root cause analysis**: The save flow in `actual-adjust.tsx` was architecturally correct (store updates happen only after successful Supabase write), but had three issues:
  1. **Silent failure on save error**: The outer catch block (line 462) only logged in `__DEV__` mode and showed NO user-facing error. If Supabase write failed, the user got no feedback and `router.back()` was never called — but since the store wasn't updated either, navigating back showed old data, making it look like the edit "reverted."
  2. **TypeScript type mismatch**: `source: 'actual_adjust'` was set in the meta object, but `CalendarEventMeta.source` only allowed `'user' | 'system' | 'evidence' | 'derived'`. The literal was widened to `string` at runtime (accepted as JSON), but TypeScript flagged it as an error.
  3. **Re-derivation overwrite risk**: When a user edits a derived event (ID like `derived_actual:xxx`), `actual-adjust.tsx` creates a NEW event via `createActual()` with a fresh UUID. But `syncDerivedActualEvents` could re-create the original derived event on the next sync cycle if the time range/kind didn't exactly match (e.g., user changed the time).
- **Fixes applied**:
  - `actual-adjust.tsx`: Added `Alert.alert('Save failed', ...)` in the outer catch block (always shown, not just `__DEV__`). Changed `source: 'actual_adjust'` to `source: 'actual_adjust' as const` to fix TypeScript type widening.
  - `events-store.ts`: Added `'actual_adjust'` to the `CalendarEventMeta.source` union type.
  - `calendar-events.ts` (`syncDerivedActualEvents`): Added tracking of user-edited event time ranges (`source: 'actual_adjust'` or `source: 'user'`), and added an overlap check that skips derived event insertion if it overlaps any user-edited event.
- **Verified correct existing behavior**:
  - `updateActual()` in `calendar-events.ts` correctly calls Supabase `.update().eq('id', eventId).select('*').single()` and returns the mapped `ScheduledEvent`.
  - Store updates (`updateActualEvent`/`addActualEvent`) happen only AFTER the `await createActual()` / `await updateActual()` calls succeed.
  - `buildActualDisplayEvents` in `actual-display-events.ts` already protects events with `source: 'actual_adjust'` — they are skipped during sleep overlap removal and given highest priority in overlap resolution sorting.
  - `source: 'actual_adjust'` was already being set in meta (line 387), so the acceptance criteria for adding it was already met.
- **Files changed**:
  - `apps/mobile/src/app/actual-adjust.tsx` — Added user-visible Alert on save failure, added `as const` for source literal
  - `apps/mobile/src/stores/events-store.ts` — Added `'actual_adjust'` to CalendarEventMeta.source type union
  - `apps/mobile/src/lib/supabase/services/calendar-events.ts` — `syncDerivedActualEvents` now tracks user-edited event time ranges and skips derived events that overlap them
- **Learnings for future iterations:**
  - The save flow correctly uses await-then-store pattern (no optimistic updates). Edits persist because: (1) `await createActual()`/`updateActual()` writes to Supabase, (2) the returned ScheduledEvent is then stored locally via `addActualEvent()`/`updateActualEvent()`. If step 1 fails, step 2 never runs.
  - `CalendarEventMeta.source` type must include all source values used in the codebase. When adding a new source, update the union in `events-store.ts`.
  - TypeScript widens string literals in object literals. Use `as const` on the literal value to keep narrow types, rather than annotating the entire object.
  - `syncDerivedActualEvents` can re-create derived events that a user has already edited if the overlap check isn't robust. The fix adds time-range overlap checking against `source: 'actual_adjust'` and `source: 'user'` events.
  - The `shouldCreate` check in actual-adjust.tsx (lines 410-413) creates new events for derived IDs. This is correct — derived events are ephemeral display IDs; the user edit creates a permanent Supabase record.
---
